part of 'yaml_document.dart';

final _defaultGlobalTag = MapEntry(TagHandle.secondary(), yamlGlobalTag);

/// A map with functions linked to a tag suffix
typedef _Resolvers = Map<TagShorthand, ResolverCreator>;

/// A [YamlDocument] parser.
final class DocumentParser {
  DocumentParser(
    this._scanner, {
    required void Function(bool isInfo, String message) logger,
    required void Function(
      RuneOffset keyStart,
      RuneOffset keyEnd,
      String message,
    )
    onMapDuplicate,
    List<Resolver>? resolvers,
  }) : _logger = logger,
       _onMapDuplicate = onMapDuplicate,
       _resolvers = (resolvers ?? []).fold({}, (p, c) {
         final Resolver(:target, :creator) = c;
         p[target] = creator;
         return p;
       });

  /// Scanner with source string
  final GraphemeScanner _scanner;

  /// Custom functions to resolve a node
  final _Resolvers _resolvers;

  /// Logging function for warnings and info
  final void Function(bool isInfo, String message) _logger;

  /// Callback used to report keys that are duplicates in flow/block maps
  final void Function(RuneOffset keyStart, RuneOffset keyEnd, String message)
  _onMapDuplicate;

  /// Global directives.
  ///
  /// Secondary tag always resolves
  final _globalTags = Map.fromEntries([_defaultGlobalTag]);

  /// Index of document being parsed
  int _currentIndex = -1;

  /// Index of document being parsed
  int get nextDocIndex => _currentIndex + 1;

  /// Char sequence that terminated the last document.
  ///
  /// If `...`, the parser looks for directives first before parsing can
  /// start until an explicit `---` is encountered. Throws an error otherwise.
  ///
  /// If `---`, the parser starts parsing nodes immediately. This also limits
  /// the use of `%` as the first character for plain style-like nodes, that is,
  /// [ScalarStyle.plain], [ScalarStyle.literal] and [ScalarStyle.folded]. The
  /// character cannot be used if the indent level is `0`.
  String _lastWasDocEndChars = '';

  /// Tracks if the current document has an explicit start.
  ///
  /// End of directives. `---` at beginning.
  bool _docStartExplicit = false;

  /// Tracks if last document had an explicit end.
  ///
  /// `...` at the end.
  bool _docEndExplicit = false;

  /// Tracks whether the root node start on the same line as the directives
  /// end marker (`---`).
  bool _rootInMarkerLine = false;

  /// Tracks whether any directives were declared
  bool _hasDirectives = false;

  /// Tracks the start offset of any characters consumed when checking for
  /// the directive end markers.
  ({RuneOffset start, String greedChars})? _docMarkerGreedy;

  /// Tracks anchors that can be used as aliases
  final _anchorNodes = <String, YamlSourceNode>{};

  /// Buffers all parsed comments
  var _comments = <YamlComment>[];

  /// Tracks [YamlSourceNode] generated by the [delegate] if [properties] is
  /// not null and anchor is present.
  ParserDelegate _trackAnchor(
    ParserDelegate delegate,
    ParsedProperty property,
  ) {
    delegate.updateNodeProperties = property;

    if (property case NodeProperty(:final String anchor)) {
      _anchorNodes[anchor] = delegate.parsed();
      return delegate;
    }

    return delegate;
  }

  /// Returns an [AliasDelegate] if [properties] has an alias. Otherwise,
  /// throws.
  ///
  /// Consider using [_nullOrAlias] or [_aliasKeyOrNull] depending on the
  /// context which are lenient.
  AliasDelegate _referenceAlias(
    Alias property, {
    required int indentLevel,
    required int indent,
    required RuneOffset start,
  }) {
    final Alias(:alias, :span) = property;

    if (_anchorNodes[alias] case YamlSourceNode node) {
      return AliasDelegate(
        node,
        indentLevel: indentLevel,
        indent: indent,
        start: start,
      );
    }

    throwWithRangedOffset(
      _scanner,
      message: 'Alias is not a valid anchor reference',
      start: span.start,
      end: span.end,
    );
  }

  /// Returns `null` if [property] object is empty.
  ///
  /// If [property] is not empty and:
  ///   1. It is an alias, then an [AliasDelegate].
  ///   2. Has an anchor or tag, then a [ScalarDelegate] wrapping `null`
  ParserDelegate? _nullOrAlias(
    ParsedProperty property, {
    required int indentLevel,
    required int indent,
    required RuneOffset start,
    required RuneOffset end,
  }) {
    final node = property.isAlias
        ? _referenceAlias(
            property as Alias,
            indentLevel: indentLevel,
            indent: indent,
            start: start,
          )
        : property.parsedAny
        ? nullScalarDelegate(
            indentLevel: indentLevel,
            indent: indent,
            startOffset: start,
          )
        : null;

    return node != null
        ? _trackAnchor(node..updateEndOffset = end, property)
        : node;
  }

  /// Returns `true` if a flow key was "json-like", that is, a single/double
  /// quoted plain scalar or flow map/sequence.
  bool _keyIsJsonLike(ParserDelegate? delegate) {
    /// Flow node with indicators:
    ///   - Single & double quoted scalars
    ///   - Flow map & sequence
    return switch (delegate) {
      ScalarDelegate(
        preScalar: PreScalar(
          scalarStyle: ScalarStyle.singleQuoted || ScalarStyle.doubleQuoted,
        ),
      ) ||
      CollectionDelegate(collectionStyle: NodeStyle.flow) => true,
      _ => false,
    };
  }

  /// Resets the parser's internal state variables before a new [YamlDocument]
  /// is parsed.
  void _restartParser() {
    ++_currentIndex; // Move to next document

    if (_currentIndex == 0) return;

    _hasDirectives = false;
    _docStartExplicit = false;
    _docEndExplicit = false;

    _rootInMarkerLine = false;

    _globalTags
      ..clear()
      ..addEntries([_defaultGlobalTag]);

    _docMarkerGreedy = null;
    _anchorNodes.clear();
    _comments = [];
  }

  /// Tracks the [marker] information after a [YamlDocument] has been
  /// completely parsed.
  void _updateDocEndChars(DocumentMarker marker) {
    _lastWasDocEndChars = marker.indicator;
    _docEndExplicit = marker == DocumentMarker.documentEnd;

    if (_docEndExplicit &&
        _scanner.charAtCursor.isNotNullAnd(
          (c) => c == comment || c.isWhiteSpace() || c.isLineBreak(),
        )) {
      skipToParsableChar(_scanner, comments: _comments);
    }
  }

  /// Resolves a [localTag] to a [GlobalTag] uri if present.
  ///
  /// If any [Resolver] matching the [localTag] is found, a
  /// [TypeResolverTag] is returned.
  ResolvedTag? _resolveTag(
    RuneOffset start,
    RuneOffset end,
    TagShorthand localTag,
  ) {
    final TagShorthand(:tagHandle, :content) = localTag;

    SpecificTag prefix = localTag;
    TagShorthand? suffix; // Local tags have no suffixes

    // Check if alias to global tag
    final globalTag = _globalTags[tagHandle];
    final hasGlobalTag = globalTag != null;

    switch (tagHandle.handleVariant) {
      // All named tags must have a corresponding global tag
      case TagHandleVariant.named:
        {
          if (!hasGlobalTag) {
            throwWithRangedOffset(
              _scanner,
              start: start,
              end: end,
              message: 'Named tags must have a corresponding global tag',
            );
          } else if (content.isEmpty) {
            throwWithRangedOffset(
              _scanner,
              start: start,
              end: end,
              message: 'Named tags must have a non-empty suffix',
            );
          }

          continue resolver;
        }

      // Secondary tags limited to tags only supported by YAML
      case TagHandleVariant.secondary when !isYamlTag(localTag):
        throwWithRangedOffset(
          _scanner,
          message:
              'Invalid secondary tag. Expected any of: '
              '$mappingTag, $sequenceTag, ${scalarTags.join(', ')}',
          start: start,
          end: end,
        );

      resolver:
      default:
        {
          if (hasGlobalTag) {
            prefix = globalTag;
            suffix = localTag; // Local tag is prefixed with global tag uri
          }
        }
    }

    /// Check if any resolvers were created. This conveniently allows
    /// non-specific tags to be captured for custom resolution before they are
    /// dropped.
    if (_resolvers[localTag] case ResolverCreator function) {
      return function(NodeTag(prefix, suffix));
    }

    return NodeTag(prefix, suffix);
  }

  /// Parses a [Scalar].
  ///
  /// [greedyOnPlain] is only ever passed when the first two plain scalar
  /// characters resemble the directive end markers `---` but the last char
  /// is not a match.
  ///
  /// See [parseNext].
  (PreScalar scalar, ScalarDelegate delegate) _parseScalar(
    ScalarEvent event, {
    required bool isImplicit,
    required bool isInFlowContext,
    required int indentLevel,
    required int minIndent,
    RuneOffset? start,
    String greedyOnPlain = '',
  }) {
    final scalarOffset = start ?? _scanner.lineInfo().current;

    final prescalar = switch (event) {
      ScalarEvent.startBlockLiteral || ScalarEvent.startBlockFolded
          when !isImplicit && !isInFlowContext && greedyOnPlain.isEmpty =>
        parseBlockStyle(
          _scanner,
          minimumIndent: minIndent,
          onParseComment: _comments.add,
        ),

      ScalarEvent.startFlowDoubleQuoted when greedyOnPlain.isEmpty =>
        parseDoubleQuoted(
          _scanner,
          indent: minIndent,
          isImplicit: isImplicit,
        ),

      ScalarEvent.startFlowSingleQuoted when greedyOnPlain.isEmpty =>
        parseSingleQuoted(
          _scanner,
          indent: minIndent,
          isImplicit: isImplicit,
        ),

      // We are aware of what character is at the start. Cannot be null
      _ when event == ScalarEvent.startFlowPlain || greedyOnPlain.isNotEmpty =>
        parsePlain(
          _scanner,
          indent: minIndent,
          charsOnGreedy: greedyOnPlain,
          isImplicit: isImplicit,
          isInFlowContext: isInFlowContext,
        ),

      _ => throwForCurrentLine(
        _scanner,
        message:
            'Failed to parse block scalar as it can never be implicit or used'
            ' in a flow context!',
      ),
    };

    /// This is a failsafe. Every map/list (flow or block) must look for
    /// ways to ensure a `null` plain scalar is never returned. This ensures
    /// the internal parsing logic for parsing the map/list is correct. Each
    /// flow/block map/list handles missing values differently.
    ///
    /// TODO: Fix later. Wrap while parsing plain scalar?
    /// TODO(cont): If fixing, consider how this null is handled by each
    /// TODO(cont): flow/block collection beforehand
    if (prescalar == null) {
      throw throwForCurrentLine(
        _scanner,
        message: 'Null was returned when parsing a plain scalar!',
      );
    }

    return (
      prescalar,
      ScalarDelegate(
        indentLevel: indentLevel,
        indent: minIndent,
        start: scalarOffset,
      )..scalar = prescalar,
    );
  }

  /// Ensures the map's state is valid before the next map entry can be parsed.
  /// This is incredibly crucial for [NodeStyle.block] maps since they have
  /// no explicit indicators and must check if the [parsedProperties] can be
  /// handed off correctly.
  ///
  /// See [_parseBlockMap] and [_parseFlowMap].
  _MapPreflightInfo _checkMapState(
    ParsedProperty property, {
    required bool isBlockContext,
    required int minMapIndent,
  }) {
    final event = inferNextEvent(
      _scanner,
      isBlockContext: isBlockContext,
      lastKeyWasJsonLike: false,
    );

    bool ensureMapIsSafe(int? indentOnExit) {
      if (indentOnExit != null) {
        if (isBlockContext) {
          _throwIfDangling(minMapIndent, indentOnExit, allowProperties: false);
          return indentOnExit == minMapIndent;
        } else if (indentOnExit < minMapIndent) {
          throwWithApproximateRange(
            _scanner,
            message:
                'Expected at least ${minMapIndent - indentOnExit} additional'
                'spaces',
            current: _scanner.lineInfo().current,
            charCountBefore: indentOnExit,
          );
        }
      }

      return true;
    }

    final ParsedProperty(:indentOnExit, :parsedAny, :span, :isMultiline) =
        property;

    if (event
        case BlockCollectionEvent.startExplicitKey ||
            FlowCollectionEvent.startExplicitKey) {
      var blockMapContinue = true;
      int? exitIndent;

      /// Explicit keys cannot have properties. Most parsing functions do use
      /// the [_parseNodeProperties] function to also skip to the next parsable
      /// char

      if (parsedAny) {
        throwWithRangedOffset(
          _scanner,
          message:
              'Explicit keys cannot have any node properties before the "?" '
              'indicator',
          start: span.start,
          end: span.end,
        );
      }

      blockMapContinue = ensureMapIsSafe(indentOnExit);
      exitIndent = indentOnExit;

      return (
        event: event,
        hasProperties: false,
        blockMapContinue: blockMapContinue,
        isExplicitEntry: true,
        indentOnExit: exitIndent,
      );
    }

    // Implicit keys cannot span multiple lines
    if (parsedAny) {
      /// We need to be graceful to the map state for flow maps. Flow maps
      /// can have keys without any values. Ergo, we need to avoid penalizing
      /// the map if parsinng will end immediately after the key is
      /// referenced/marked as null key with properties.
      if (isMultiline &&
          !(!isBlockContext &&
              _scanner.charAtCursor.isNotNullAnd(
                (c) => c == flowEntryEnd || c == mappingEnd,
              ))) {
        throwWithRangedOffset(
          _scanner,
          message:
              'Node properties for an implicit '
              '${isBlockContext ? 'block' : 'flow'}'
              ' key cannot span multiple lines',
          start: span.start,
          end: span.end,
        );
      }

      return (
        event: event,
        hasProperties: true,
        isExplicitEntry: false,
        blockMapContinue: ensureMapIsSafe(indentOnExit),
        indentOnExit: indentOnExit,
      );
    }

    return (
      event: event,
      hasProperties: false,
      isExplicitEntry: false,
      blockMapContinue: true,
      indentOnExit: null,
    );
  }

  /// Returns an [AliasDelegate] with the specified [indentLevel], [indent] and
  /// starting at the [keyStartOffset] if [properties] is not null and and an
  /// `alias` is present.
  ///
  /// See [_parseBlockMap] and [_parseFlowMap].
  ParserDelegate? _aliasKeyOrNull(
    ParsedProperty property, {
    ParserDelegate? existing,
    required int indentLevel,
    required int indent,
    required RuneOffset keyStartOffset,
  }) {
    if (property is Alias) {
      if (existing != null) {
        throw ArgumentError.value(
          existing,
          'existing',
          'An existing key found while attempting to reference an alias',
        );
      }

      return _referenceAlias(
        property,
        indentLevel: indentLevel,
        indent: indent,
        start: keyStartOffset,
      );
    }

    return null;
  }

  /// Skips to the next parsable flow indicator/character.
  ///
  /// If declared on a new line and [forceInline] is `false`, the flow
  /// indicator/character must be indented at least [minIndent] spaces. Throws
  /// otherwise.
  bool _nextSafeLineInFlow(int minIndent, {required bool forceInline}) {
    final indent = skipToParsableChar(_scanner, comments: _comments);

    if (indent != null) {
      // Must not have line breaks
      if (forceInline) {
        throwWithApproximateRange(
          _scanner,
          message: 'Found a line break when parsing an inline flow node',
          current: _scanner.lineInfo().current,
          charCountBefore: indent + 2, // Highlight upto the previous line
        );
      }

      /// If line breaks are allowed, it must at least be the same or
      /// greater than the min indent. Indent serves no purpose in flow
      /// collections. The min indent is used as markup indent enforced parent
      /// block collection
      if (indent < minIndent) {
        throwWithApproximateRange(
          _scanner,
          message: 'Expected at least ${minIndent - indent} additional spaces',
          current: _scanner.lineInfo().current,
          charCountBefore: indent,
        );
      }
    } else if (!_scanner.canChunkMore) {
      return false;
    }

    return true;
  }

  /// Returns `true` if [_parseFlowSequence] or [_parseFlowMap] can parse the
  /// next flow entry or flow map entry respectively.
  bool _continueToNextEntry(int minIndent, {required bool forceInline}) {
    _nextSafeLineInFlow(minIndent, forceInline: forceInline);

    if (_scanner.charAtCursor == flowEntryEnd) {
      _scanner.skipCharAtCursor();
      return _nextSafeLineInFlow(minIndent, forceInline: forceInline);
    }

    return false;
  }

  /// Throws if the current char doesn't match the flow collection [delimiter]
  void _throwIfNotFlowDelimiter(int delimiter) {
    skipToParsableChar(_scanner, comments: _comments);

    final char = _scanner.charAtCursor;

    if (char != delimiter) {
      throwWithSingleOffset(
        _scanner,
        message: 'Expected the flow delimiter: "${delimiter.asString()}"',
        offset: _scanner.lineInfo().current,
      );
    }

    _scanner.skipCharAtCursor(); // Skip it if valid
  }

  /// Parses a flow node, that is, a map/sequence/scalar.
  ParserDelegate _parseFlowNode({
    required bool isParsingKey,
    required int currentIndentLevel,
    required int minIndent,
    required bool forceInline,
    required bool isExplicitKey,
    required bool keyIsJsonLike,
    required int collectionDelimiter,
    bool isBlockContext = false, // Block styles should override
    ParserEvent? inferredEvent,
    RuneOffset? startOffset,
  }) {
    final event =
        inferredEvent ??
        inferNextEvent(
          _scanner,
          isBlockContext: false,
          lastKeyWasJsonLike: keyIsJsonLike,
        );

    final flowStartOffset = startOffset ?? _scanner.lineInfo().current;

    if (!event.isFlowContext) {
      throwWithSingleOffset(
        _scanner,
        message: 'Expected a flow node but found a block node indicator',
        offset: flowStartOffset,
      );
    }

    final isImplicitKey = isParsingKey && !isExplicitKey;

    switch (event) {
      case FlowCollectionEvent.startEntryValue when isParsingKey:
        return nullScalarDelegate(
          indentLevel: currentIndentLevel,
          indent: minIndent,
          startOffset: flowStartOffset,
        )..updateEndOffset = flowStartOffset;

      case FlowCollectionEvent.startExplicitKey:
        {
          _scanner.skipCharAtCursor();

          if (!_nextSafeLineInFlow(minIndent, forceInline: forceInline)) {
            throwWithSingleOffset(
              _scanner,
              message:
                  'Expected the flow delimiter '
                  '"${collectionDelimiter.asString()}" but found nothing',
              offset: _scanner.lineInfo().current,
            );
          }

          final char = _scanner.charAtCursor;

          if (char == flowEntryEnd || char == collectionDelimiter) {
            return nullScalarDelegate(
              indentLevel: currentIndentLevel,
              indent: minIndent,
              startOffset: flowStartOffset,
            )..updateEndOffset = _scanner.lineInfo().current;
          }

          return _parseFlowNode(
            isParsingKey: isParsingKey,
            currentIndentLevel: currentIndentLevel,
            minIndent: minIndent,
            forceInline: forceInline,
            isExplicitKey: true,
            keyIsJsonLike: keyIsJsonLike,
            collectionDelimiter: collectionDelimiter,
            startOffset: flowStartOffset,
          );
        }

      case FlowCollectionEvent.startFlowMap:
        {
          final map = MappingDelegate(
            collectionStyle: NodeStyle.flow,
            indentLevel: currentIndentLevel + 1,
            indent: minIndent,
            start: flowStartOffset,
          );

          _parseFlowMap(map, forceInline: forceInline || isImplicitKey);
          return map;
        }

      case FlowCollectionEvent.startFlowSequence:
        {
          final sequence = SequenceDelegate(
            collectionStyle: NodeStyle.flow,
            indentLevel: currentIndentLevel + 1,
            indent: minIndent,
            start: flowStartOffset,
          );

          _parseFlowSequence(
            sequence,
            forceInline: forceInline || isImplicitKey,
          );
          return sequence;
        }

      case ScalarEvent _:
        {
          final (prescalar, delegate) = _parseScalar(
            event,
            isImplicit: forceInline || isImplicitKey,
            isInFlowContext: true,
            indentLevel: currentIndentLevel,
            minIndent: minIndent,
            start: flowStartOffset,
          );

          /// Plain scalars can have document/directive end chars embedded
          /// in the content. If not implicit, it can be affected by indent
          /// changes since it has a block-like structure
          if (prescalar case PreScalar(
            scalarStyle: ScalarStyle.plain,
            :final indentOnExit,
            :final indentDidChange,
            :final docMarkerType,
          ) when !isImplicitKey || !forceInline) {
            // Flow node only ends after parsing a flow delimiter
            if (docMarkerType.stopIfParsingDoc) {
              throwForCurrentLine(
                _scanner,
                message:
                    'Premature document termination when parsing flow map '
                    'entry',
              );
            }

            // Must not detect an indent change less than flow indent
            if (indentDidChange && indentOnExit < minIndent) {
              throwWithApproximateRange(
                _scanner,
                message:
                    'Indent change detected when parsing plain scalar. Expected'
                    ' $minIndent space(s) but found $indentOnExit space(s)',
                current: _scanner.lineInfo().current,
                charCountBefore: indentOnExit,
              );
            }
          }

          return delegate;
        }

      case FlowCollectionEvent.nextFlowEntry
          when !isBlockContext && (!isParsingKey || isExplicitKey):
        {
          return nullScalarDelegate(
            indentLevel: currentIndentLevel,
            indent: minIndent,
            startOffset: flowStartOffset,
          )..updateEndOffset = flowStartOffset;
        }

      default:
        // Easier to debug and help diagnose unimplemented behaviour
        throwWithRangedOffset(
          _scanner,
          message:
              'Internal Parser Error. Should not be parsing flow node here',
          start: flowStartOffset,
          end: _scanner.lineInfo().current,
        );
    }
  }

  /// Parses a single flow map entry.
  (ParserDelegate? key, ParserDelegate? value) _parseFlowMapEntry(
    ParserDelegate? key, {
    required int indentLevel,
    required int minIndent,
    required bool forceInline,
    required int exitIndicator,
    required ParsedProperty keyProperty,
    RuneOffset? startOffset,
  }) {
    var parsedKey = key;
    ParserDelegate? value;

    if (!_nextSafeLineInFlow(minIndent, forceInline: forceInline)) {
      throwWithSingleOffset(
        _scanner,
        message:
            'Expected the flow delimiter "${exitIndicator.asString()}" but '
            'found null',
        offset: _scanner.lineInfo().current,
      );
    } else if (_scanner.charAtCursor == exitIndicator) {
      final keyEnd = _scanner.lineInfo().current;

      // This "if" is intentional. I want to update the end offset just once.
      if (parsedKey == null) {
        parsedKey = _nullOrAlias(
          keyProperty,
          indentLevel: indentLevel,
          indent: minIndent,
          start: startOffset ?? _scanner.lineInfo().current,
          end: keyEnd,
        );
      } else {
        parsedKey
          ..updateNodeProperties = keyProperty
          ..updateEndOffset = keyEnd;
      }

      return (parsedKey, value);
    }

    /// We must not see the next entry before the key
    if (_scanner.charAtCursor case flowEntryEnd when key == null) {
      throwWithSingleOffset(
        _scanner,
        message: 'Expected at least a key before the next flow map entry',
        offset: _scanner.lineInfo().current,
      );
    }

    parsedKey ??= _parseFlowNode(
      isParsingKey: true,
      startOffset: startOffset,
      currentIndentLevel: indentLevel,
      minIndent: minIndent,
      forceInline: forceInline,

      /// Defaults to false. The function will recursively infer internally
      /// if `true` and act accordingly
      isExplicitKey: false,
      keyIsJsonLike: false,
      collectionDelimiter: exitIndicator,
    );

    final expectedCharErr =
        'Expected a next flow entry indicator "," or a map value indicator ":" '
        'or a terminating delimiter "${exitIndicator.asString()}"';

    if (!_nextSafeLineInFlow(minIndent, forceInline: forceInline)) {
      throwWithSingleOffset(
        _scanner,
        message: expectedCharErr,
        offset: _scanner.lineInfo().current,
      );
    }

    /// Checks if we should parse a value or ignore it
    bool ignoreValue(int? char) =>
        char == null || char == flowEntryEnd || char == exitIndicator;

    final valueOffset = _scanner.lineInfo().current;
    parsedKey.updateEndOffset = valueOffset;

    _trackAnchor(parsedKey, keyProperty);

    // Check if this is the start of a flow value
    if (inferNextEvent(
              _scanner,
              isBlockContext: false,
              lastKeyWasJsonLike: _keyIsJsonLike(parsedKey),
            ) ==
            FlowCollectionEvent.startEntryValue ||
        _scanner.charAtCursor == mappingValue) {
      _scanner.skipCharAtCursor(); // ":"

      final (:event, :property) = parseSimpleFlowProps(
        _scanner,
        minIndent: minIndent,
        resolver: _resolveTag,
        comments: _comments,
        lastKeyWasJsonLike: false, // no effect
      );

      final valueLevel = indentLevel + 1;

      /// Having a ":" changes the layout dynamics. This means the value is
      /// present-ish by virtue of having seen the delimiter. This ensures
      /// we provide the correct end offset for an editor trying to make
      /// edits to the source. Such that:
      ///
      ///
      /// {
      /// key,
      ///    ^ Key ends here by default. Value null, non-existent (virtual)
      ///
      /// key:,
      ///    ^^ Key ends at the first caret. Value is null, but exists since
      ///       the ":" is present. Thus a "physical" null that ends at the
      ///       second caret.
      /// }
      if (property is Alias) {
        value =
            _referenceAlias(
                property,
                indentLevel: valueLevel,
                indent: minIndent,
                start: valueOffset,
              )
              ..updateNodeProperties = property
              ..updateEndOffset = _scanner.lineInfo().current;
      } else {
        value = _trackAnchor(
          ignoreValue(_scanner.charAtCursor)
              ? (nullScalarDelegate(
                  indentLevel: valueLevel,
                  indent: minIndent,
                  startOffset: valueOffset,
                )..updateEndOffset = _scanner.lineInfo().current)
              : _parseFlowNode(
                  inferredEvent: event,
                  isParsingKey: false,
                  currentIndentLevel: valueLevel,
                  minIndent: minIndent,
                  forceInline: forceInline,
                  isExplicitKey: false,
                  keyIsJsonLike: false, // No effect here
                  collectionDelimiter: exitIndicator,
                ),
          property,
        );
      }
    } else if (!ignoreValue(_scanner.charAtCursor)) {
      // Must at least be end of parser, "," and ["}" if map or "]" if list]
      throwWithSingleOffset(
        _scanner,
        message: expectedCharErr,
        offset: _scanner.lineInfo().current,
      );
    }

    return (parsedKey, value);
  }

  /// Parses a flow map.
  ///
  /// If [forceInline] is `true`, the map must be declared on the same line
  /// with no line breaks and throws if otherwise.
  void _parseFlowMap(MappingDelegate delegate, {required bool forceInline}) {
    _throwIfNotFlowDelimiter(mappingStart);

    final MappingDelegate(:indent, :indentLevel) = delegate;

    /// We need to ensure we don't unintentionally make the first key's
    /// property's multiline if implicit and declared inline. This may happen
    /// if the first key is not declared on the same line as the "{".
    _nextSafeLineInFlow(indent, forceInline: forceInline);

    while (_scanner.canChunkMore) {
      final keyOffset = _scanner.lineInfo().current;

      final property = parseNodeProperties(
        _scanner,
        minIndent: indent,
        resolver: _resolveTag,
        comments: _comments,
      );

      _checkMapState(property, isBlockContext: false, minMapIndent: indent);

      final (key, value) = _parseFlowMapEntry(
        _aliasKeyOrNull(
          property,
          indentLevel: indentLevel,
          indent: indent,
          keyStartOffset: keyOffset,
        ),
        startOffset: keyOffset,
        indentLevel: indentLevel,

        /// As per YAML, no need forcing indentation in flow map as long as it
        /// adheres to the minimum indent set by block parent if in block
        /// context. If in flow context, let it "flow" and lay itself!
        minIndent: indent,
        keyProperty: property,
        forceInline: forceInline,
        exitIndicator: mappingEnd,
      );

      /// If our key is null, it means no parsing occured. The
      /// [_parseFlowMapEntry] guarantees that it will return a wrapped null
      /// key when no key was parsed.
      ///
      /// TODO: Test if the key can be null if any props are present
      if (key == null) break;

      // Map already contains key
      if (!delegate.pushEntry(key, value)) {
        _onMapDuplicate(
          key.start,
          value?.start ?? _scanner.lineInfo().current,
          'Flow map cannot contain duplicate entries by the same key',
        );
      }

      // Only continues if current non-space character is a ","
      if (!_continueToNextEntry(indent, forceInline: forceInline)) {
        break;
      }
    }

    _throwIfNotFlowDelimiter(mappingEnd);
    delegate.updateEndOffset = _scanner.lineInfo().current;
  }

  /// Returns `true` if any trailing empty scalar was added to the [sequence]
  /// only if [property] has any properties embedded.
  bool _checkTrailingEntry(
    SequenceDelegate sequence, {
    required ParsedProperty property,
    required RuneOffset start,
    required int indentLevel,
    required int indent,
    RuneOffset? end,
  }) {
    if (_nullOrAlias(
          property,
          indentLevel: indentLevel,
          indent: indent,
          start: start,
          end: end ?? _scanner.lineInfo().current,
        )
        case ParserDelegate entry) {
      sequence.pushEntry(entry);
      return true;
    }

    return false;
  }

  /// Parse a flow sequence/list.
  ///
  /// If [forceInline] is `true`, the list must be declared on the same line
  /// with no line breaks and throws if otherwise.
  void _parseFlowSequence(
    SequenceDelegate delegate, {
    required bool forceInline,
  }) {
    _throwIfNotFlowDelimiter(flowSequenceStart);

    final SequenceDelegate(:indent, :indentLevel) = delegate;

    /// Similar to flow map, move this to the first parsable char. This has
    /// little effect for other sequence entries but may be crucial to
    /// compact maps (flow map entries without leading "{" and trailing "}")
    /// that may suffer from the same issue we want to suppress in a flow
    /// map's first key.
    _nextSafeLineInFlow(indent, forceInline: forceInline);

    listParser:
    while (_scanner.canChunkMore) {
      final flowStartOffset = _scanner.lineInfo().current;

      final (:event, :property) = parseSimpleFlowProps(
        _scanner,
        minIndent: indent,
        resolver: _resolveTag,
        comments: _comments,
      );

      // We will always have a char here
      switch (event) {
        case FlowCollectionEvent.nextFlowEntry:
          {
            // We don't need to throw if we saw any anchor or alias
            if (_checkTrailingEntry(
              delegate,
              property: property,
              start: flowStartOffset,
              indentLevel: indentLevel,
              indent: indent,
            )) {
              break;
            }

            throwWithSingleOffset(
              _scanner,
              message: delegate.isEmpty
                  ? 'Expected to find the first value but found ","'
                  : 'Found a duplicate "," before finding a flow sequence '
                        'entry',
              offset: _scanner.lineInfo().current,
            );
          }

        // Parse explicit key
        case FlowCollectionEvent.startExplicitKey:
          {
            if (property.parsedAny) {
              final (:start, :end) = property.span;

              throwWithRangedOffset(
                _scanner,
                message:
                    'Explicit keys cannot have any node properties before '
                    'the "?" indicator',
                start: start,
                end: end,
              );
            }

            final (key, value) = _parseFlowMapEntry(
              null,
              indentLevel: indentLevel,
              minIndent: indent,
              keyProperty: ParsedProperty.empty(
                flowStartOffset,
                flowStartOffset,
                null,
                spanMultipleLines: false,
              ),
              forceInline: forceInline,
              exitIndicator: flowSequenceEnd,
            );

            /// The key cannot be null since we know it is explicit.
            /// [_parseFlowMapEntry] will wrap it in a null key. However, for
            /// null safety, just check
            if (key == null) break listParser;

            delegate.pushEntry(
              MapEntryDelegate(nodeStyle: NodeStyle.flow, keyDelegate: key)
                ..updateValue = value,
            );
          }

        case FlowCollectionEvent.endFlowSequence:
          {
            /// Ensure we don't exclude any trailing empty nodes that declared
            /// properties
            _checkTrailingEntry(
              delegate,
              property: property,
              start: flowStartOffset,
              indentLevel: indentLevel,
              indent: indent,
              end: property.isMultiline
                  ? _scanner.lineInfo().start
                  : _scanner.lineInfo().current,
            );

            break listParser;
          }

        default:
          {
            var keyOrElement = _aliasKeyOrNull(
              property,
              indentLevel: indentLevel,
              indent: indent,
              keyStartOffset: flowStartOffset,
            );

            // Handles all flow node types i.e map, sequence and scalars
            keyOrElement ??= _parseFlowNode(
              isParsingKey: false,
              currentIndentLevel: indentLevel,
              minIndent: indent,
              forceInline: forceInline,
              isExplicitKey: false,
              keyIsJsonLike: false,
              startOffset: flowStartOffset,
              collectionDelimiter: flowSequenceEnd,
            );

            // Go to the next parsable char
            if (!_nextSafeLineInFlow(indent, forceInline: forceInline)) {
              break listParser;
            }

            /// Normally a list is a wildcard. We must assume that we parsed
            /// an implicit key unless we never see ":". Encountering a
            /// linebreak means the current flow node cannot be an implicit key.
            ///
            /// YAML requires us to treat all keys as implicit unless explicit
            /// which are normally restricted to a single line.
            if (keyOrElement.encounteredLineBreak ||
                inferNextEvent(
                      _scanner,
                      isBlockContext: false,
                      lastKeyWasJsonLike: _keyIsJsonLike(keyOrElement),
                    ) !=
                    FlowCollectionEvent.startEntryValue) {
              delegate.pushEntry(_trackAnchor(keyOrElement, property));
              break;
            }

            // Compact implicit maps cannot have properties
            if (property.parsedAny && property.isMultiline) {
              throwWithRangedOffset(
                _scanner,
                message: 'Compact implicit map entries cannot have properties',
                start: property.span.start,
                end: _scanner.lineInfo().current,
              );
            }

            // We have the key. No need for it!
            final (_, value) = _parseFlowMapEntry(
              keyOrElement,
              indentLevel: indentLevel,
              minIndent: indent,
              keyProperty: property,
              forceInline: forceInline,
              exitIndicator: flowSequenceEnd,
            );

            delegate.pushEntry(
              MapEntryDelegate(
                nodeStyle: NodeStyle.flow,
                keyDelegate: keyOrElement,
              )..updateValue = value,
            );
          }
      }

      if (!_continueToNextEntry(indent, forceInline: forceInline)) {
        break;
      }
    }

    _throwIfNotFlowDelimiter(flowSequenceEnd);
    delegate.updateEndOffset = _scanner.lineInfo().current;
  }

  /// Calculates the indent for a block node within a block collection
  /// only if [inferred] indent is null.
  ({int laxIndent, int inlineFixedIndent}) _blockChildIndent(
    int? inferred, {
    required int blockParentIndent,
    required int startOffset,
  }) {
    if (inferred != null) {
      return (laxIndent: inferred, inlineFixedIndent: inferred);
    }

    /// Being null indicates the child is okay being indented at least "+1" if
    /// the rest of its content spans multiple lines. This applies to
    /// [ScalarStyle.literal] and [ScalarStyle.folded]. Flow collections also
    /// benefit from this as the indent serves no purpose other than respecting
    /// the current block parent's indentation. This is its [laxIndent].
    ///
    /// Its [inlineFixedIndent] is the character difference upto the current
    /// parsable char. This indent is enforced on block sequences and maps used
    /// as:
    ///   1. a block sequence entry
    ///   2. content of an explicit key
    ///   3. content of an explicit key's value
    ///
    /// "?" is used as an example but applies to all block nodes that use an
    /// indicator.
    ///
    /// (meh! No markdown hover)
    /// ```yaml
    ///
    /// # With flow. Okay
    /// ? [
    ///  "blah", "blah",
    ///  "blah"]
    ///
    /// # With literal. Applies to folded. Okay
    /// ? |
    ///  block
    ///
    /// # With literal. Applies to folded. We give "+1". Indent determined
    /// # while parsing as recommended by YAML. See [parseBlockStyle]
    /// ? |
    ///     block
    ///
    /// # With block sequences. Must do this for okay
    /// ? - blah
    ///   - blah
    ///
    /// # With implicit or explict map
    /// ? key: value
    ///   keyB: value
    ///   keyC: value # Explicit key ends here
    /// : actual-value # Explicit key's value
    ///
    /// # With block sequence. If this is done. Still okay. Inferred.
    /// ?
    ///  - blah
    ///  - blah
    ///
    /// ```
    return (
      laxIndent: blockParentIndent + 1,
      inlineFixedIndent:
          blockParentIndent +
          (_scanner.lineInfo().current.utfOffset - startOffset),
    );
  }

  /// Parses a block scalar.
  ///
  /// Block scalars can create in an implicit block map if declared on a new
  /// line. If [degenerateToImplicitMap] is `true`, then this function attempts
  /// to greedily parse a block map if possible.
  ///
  ///
  _BlockNode _parseBlockScalarWildcard(
    ScalarEvent event, {
    required RuneOffset startOffset,
    required int laxIndent,
    required int fixedIndent,
    required int indentLevel,
    required bool isInlined,
    required bool degenerateToImplicitMap,
    required bool parentEnforcedCompactness,
    required ParsedProperty scalarProperty,
    String greedOnPlain = '',
  }) {
    final (
      PreScalar(
        :docMarkerType,
        :indentDidChange,
        :indentOnExit,
        :hasLineBreak,
      ),
      delegate,
    ) = _parseScalar(
      event,
      isImplicit: isInlined,
      isInFlowContext: false,
      indentLevel: indentLevel,
      minIndent: laxIndent, // Parse with minimum allowed indent
      start: startOffset,
      greedyOnPlain: greedOnPlain,
    );

    /// - Block keys cannot degenerate to implicit maps. Only flow keys.
    /// - We also need to make sure that the plain scalar didn't exit due to
    ///   an indent change.
    /// - Any scalar with a line break cannot be an implicit key
    if (!_scanner.canChunkMore ||
        !event.isFlowContext ||
        !degenerateToImplicitMap ||
        docMarkerType.stopIfParsingDoc ||
        hasLineBreak ||
        indentDidChange) {
      return (
        delegate: _trackAnchor(delegate, scalarProperty),
        nodeInfo: (exitIndent: indentOnExit, docMarker: docMarkerType),
      );
    }

    return _parseWildcardBlockMap(
      delegate,
      mapIndentLvel: indentLevel,
      mapFixedIndent: fixedIndent,
      keyProperty: scalarProperty,
      parentEnforcedCompactness: parentEnforcedCompactness,
      eventIfScalar: event,
    );
  }

  /// Parses a block [Mapping] after parsing an implicit scalar key.
  _BlockNode _parseWildcardBlockMap(
    ParserDelegate blockKey, {
    required int mapIndentLvel,
    required int mapFixedIndent,
    required ParsedProperty keyProperty,
    required bool parentEnforcedCompactness,
    ScalarEvent? eventIfScalar,
  }) {
    var charAtCursor = _scanner.charAtCursor;

    if (eventIfScalar == ScalarEvent.startFlowDoubleQuoted ||
        eventIfScalar == ScalarEvent.startFlowSingleQuoted ||
        charAtCursor != mappingValue) {
      final greedyIndent = skipToParsableChar(_scanner, comments: _comments);
      charAtCursor = _scanner.charAtCursor;

      // The indent must be null. This must be an inlined key.
      if (!_scanner.canChunkMore ||
          greedyIndent != null ||
          charAtCursor != mappingValue) {
        return (
          delegate: _trackAnchor(blockKey, keyProperty),
          nodeInfo: (
            exitIndent: greedyIndent,
            docMarker: DocumentMarker.none,
          ),
        );
      }
    }

    // Always throw if this isn't a ":". It must be!
    if (inferNextEvent(
          _scanner,
          isBlockContext: true,
          lastKeyWasJsonLike: false,
        ) !=
        BlockCollectionEvent.startEntryValue) {
      throwWithRangedOffset(
        _scanner,
        message: 'Expected a ":" after this key',
        start: blockKey.start,
        end: _scanner.lineInfo().current,
      );
    }

    final map = MappingDelegate(
      collectionStyle: NodeStyle.block,
      indentLevel: mapIndentLvel,

      /// Map must now use the fixed indent we calculated. Forcing all keys to
      /// be aligned with the first key
      indent: mapFixedIndent,
      start: blockKey.start, // Use offset of first key
    );

    // Compact nodes cannot have properties
    if (keyProperty.parsedAny && parentEnforcedCompactness) {
      throwWithRangedOffset(
        _scanner,
        message: 'Compact implicit block maps cannot have node properties',
        start: keyProperty.span.start,
        end: _scanner.lineInfo().current,
      );
    }

    /// Give key its properties. Prevent overwrite during inference
    if (!keyProperty.isMultiline) {
      _trackAnchor(blockKey, keyProperty);
    }

    final mapInfo = _parseBlockMap(map, blockKey, null);

    // TODO: *SIGH* This gives the ick. Will circle back with a cleaner approach
    if (keyProperty.isMultiline) {
      _trackAnchor(map, keyProperty);
    }

    return (delegate: map, nodeInfo: mapInfo);
  }

  /// Parses a flow collection embedded within a block collection.
  _BlockNode _parseEmbeddedFlowCollection(
    FlowCollectionEvent event, {
    required int indentLevel,
    required int indent,
    required bool isInlined,
    required bool isParsingKey,
    required bool isExplicitKey,
    required bool degenerateToImplicitMap,
    required bool parentEnforcedCompactness,
    required RuneOffset startOffset,
    required ParsedProperty flowProperty,
  }) {
    final flowNode = _parseFlowNode(
      /// Ensure we prevent an event check and default it to an event
      /// we are privy to thus limiting the scope of the function.
      /// Must parse a map/list. Throws otherwise, as expected.
      inferredEvent: event,

      /// Further reduces the scope of the function ensuring it throws
      /// when a "," is used at the beginning of the line. We want to ignore
      /// flow entry delimiters.
      isBlockContext: true,
      currentIndentLevel: indentLevel,
      minIndent: indent,

      isParsingKey: isParsingKey,
      isExplicitKey: isExplicitKey,
      forceInline: isInlined,
      keyIsJsonLike: false,

      /// Faux value. Never used. Block explicit keys are intercepted by the
      /// [_parseExplicitBlockEntry] function.
      collectionDelimiter: reservedAtSign,
      startOffset: startOffset,
    );

    /// In block context, always attempt to greedily treat the flow collection
    /// as a key to a block map if possible.
    return _scanner.canChunkMore &&
            degenerateToImplicitMap &&
            !flowNode.encounteredLineBreak
        ? _parseWildcardBlockMap(
            flowNode,
            mapIndentLvel: indentLevel,
            mapFixedIndent: indent,
            keyProperty: flowProperty,
            parentEnforcedCompactness: parentEnforcedCompactness,
          )
        : (
            delegate: _trackAnchor(flowNode, flowProperty),
            nodeInfo: (
              docMarker: DocumentMarker.none,
              exitIndent: skipToParsableChar(_scanner, comments: _comments),
            ),
          );
  }

  void _throwIfNotCompactCompatible(
    ParsedProperty property, {
    required bool parentEnforcedCompactness,
    required bool isBlockSequence,
  }) {
    if (!property.parsedAny) return;

    Never throwErr(String message) {
      throwWithRangedOffset(
        _scanner,
        message: message,
        start: property.span.start,
        end: _scanner.lineInfo().current,
      );
    }

    // Compact notation prevents nodes from having properties
    if (parentEnforcedCompactness) {
      throwErr('A compact block node cannot have node properties');
    } else if (!property.isMultiline) {
      throwErr(
        'Inline node properties cannot be declared before the first '
        '${isBlockSequence ? '"- "' : '"? "'} indicator',
      );
    }
  }

  /// Parses a block node within a block collection.
  _BlockNode _parseBlockNode({
    required int indentLevel,
    required int laxIndent,
    required int fixedInlineIndent,
    required bool forceInlined,
    required bool isParsingKey,
    required bool isExplicitKey,
    required bool degenerateToImplicitMap,
    required bool parentEnforcedCompactness,
    required RuneOffset startOffset,
    required ParsedProperty blockNodeProperty,
    ParserEvent? event,
  }) {
    _BlockNodeInfo? info;
    ParserDelegate? node;

    if (blockNodeProperty.isAlias) {
      // Lax indent is always the minimum
      return (
        delegate: _referenceAlias(
          blockNodeProperty as Alias,
          indentLevel: indentLevel,
          indent: laxIndent,
          start: startOffset,
        )..updateNodeProperties = blockNodeProperty,
        nodeInfo: (exitIndent: laxIndent, docMarker: DocumentMarker.none),
      );
    }

    switch (event ??
        inferNextEvent(
          _scanner,
          isBlockContext: true,
          lastKeyWasJsonLike: false,
        )) {
      case FlowCollectionEvent flowEvent:
        {
          final (:delegate, :nodeInfo) = _parseEmbeddedFlowCollection(
            flowEvent,
            indentLevel: indentLevel,
            indent: laxIndent,
            isInlined: forceInlined,
            isParsingKey: isParsingKey,
            isExplicitKey: isExplicitKey,
            degenerateToImplicitMap: degenerateToImplicitMap,
            parentEnforcedCompactness: parentEnforcedCompactness,
            startOffset: startOffset,
            flowProperty: blockNodeProperty,
          );

          node = delegate;
          info = nodeInfo;
        }

      case ScalarEvent scalarEvent:
        {
          final (:delegate, :nodeInfo) = _parseBlockScalarWildcard(
            scalarEvent,
            laxIndent: laxIndent,
            fixedIndent: fixedInlineIndent,
            indentLevel: indentLevel,
            isInlined: forceInlined,
            degenerateToImplicitMap: degenerateToImplicitMap,
            parentEnforcedCompactness: parentEnforcedCompactness,
            startOffset: startOffset,
            scalarProperty: blockNodeProperty,
          );

          info = nodeInfo;
          node = delegate;
        }

      case BlockCollectionEvent.startEntryValue:
        {
          final map = MappingDelegate(
            collectionStyle: NodeStyle.block,
            indentLevel: indentLevel,
            indent: fixedInlineIndent,
            start: startOffset,
          );

          ParserDelegate? nonExistentKey = nullScalarDelegate(
            indentLevel: indentLevel,
            indent: fixedInlineIndent,
            startOffset: startOffset,
          )..updateEndOffset = _scanner.lineInfo().current;

          ParsedProperty? keyProperty = blockNodeProperty;
          ParsedProperty mapProperty = ParsedProperty.empty(
            startOffset,
            startOffset,
            null,
            spanMultipleLines: false,
          );

          /// We want to allow the map to determine its own state. Ideally,
          /// this could be achieved here but a map can have multiple values?
          ///
          /// We want to reduce wasted cycles doing the same check. Because..
          /// <insert Spongebob meme> "A bLoCk MaP aLwAyS dEtErMiNeS iT's StAtE"
          /// before parsing a block entry and each (implicit/explicit) block
          /// entry is handled differently.
          ///
          /// If there are no node properties. We can safely just pass a null
          /// key wrapped in a delegate
          if (blockNodeProperty.parsedAny) {
            if (blockNodeProperty.isMultiline) {
              mapProperty = blockNodeProperty;
              keyProperty = mapProperty;
            } else {
              nonExistentKey = null; //
            }
          }

          info = _parseBlockMap(map, nonExistentKey, keyProperty);
          node = _trackAnchor(map, mapProperty);
        }

      case BlockCollectionEvent.startBlockListEntry when !forceInlined:
        {
          _throwIfNotCompactCompatible(
            blockNodeProperty,
            parentEnforcedCompactness: false,
            isBlockSequence: true,
          );

          final list = SequenceDelegate(
            collectionStyle: NodeStyle.block,
            indentLevel: indentLevel,
            indent: fixedInlineIndent,
            start: startOffset,
          );

          info = _parseBlockSequence(list);
          node = _trackAnchor(list, blockNodeProperty);
        }

      case BlockCollectionEvent.startExplicitKey when !forceInlined:
        {
          _throwIfNotCompactCompatible(
            blockNodeProperty,
            parentEnforcedCompactness: parentEnforcedCompactness,
            isBlockSequence: false,
          );

          final map = MappingDelegate(
            collectionStyle: NodeStyle.block,
            indentLevel: indentLevel,
            indent: fixedInlineIndent,
            start: startOffset,
          );

          info = _parseBlockMap(map, null, null);
          node = _trackAnchor(map, blockNodeProperty);
        }

      default:
        // Debug problems and unimplemented behaviour easily
        throwWithRangedOffset(
          _scanner,
          message:
              'Internal Parser Error. Should not be parsing block node here',
          start: blockNodeProperty.span.start,
          end: _scanner.lineInfo().current,
        );
    }

    /// Make sure we have an accurate indent and not one indicating that
    /// our block(-like) scalar was not a result of anything else like a
    /// comment.
    if (!info.docMarker.stopIfParsingDoc &&
        _scanner.canChunkMore &&
        (_scanner.charAtCursor == comment ||
            info.exitIndent == seamlessIndentMarker)) {
      info = (
        exitIndent: skipToParsableChar(_scanner, comments: _comments),
        docMarker: DocumentMarker.none,
      );
    }

    return (delegate: node, nodeInfo: info);
  }

  /// Checks to see if an explicit [_BlockEntry] can be parsed.
  ///
  /// If the entry doesn't start on the next line (inline), the [startOffset]
  /// is used to compute the `inlineIndent` and the `laxIndent` is computed
  /// from the [parentIndent].
  ///
  /// If the entry does start on the next line, the `inlineIndent` and
  /// `laxIndent` are equal. In this case, if the indent `<=` [parentIndent],
  /// then this node cannot be parsed.
  ///
  /// See [_blockChildIndent] implementation.
  _ParseExplicitInfo _explicitIsParsable(int startOffset, int parentIndent) {
    _scanner.skipCharAtCursor(); // Skip the "?" or ":"

    /// Typically exists as "?"<whitespace>. We can't know what/where to
    /// start parsing. Attempt to parsed node properties. The function also
    /// skips to the next possible parsable char
    final explicitProperty = parseNodeProperties(
      _scanner,
      minIndent: parentIndent + 1,
      resolver: _resolveTag,
      comments: _comments,
    );

    // Must be able to parse more characters
    if (!_scanner.canChunkMore) {
      return (
        shouldExit: true,
        hasIndent: false,
        parsedProperty: explicitProperty,
        inferredIndent: seamlessIndentMarker,
        laxIndent: seamlessIndentMarker,
        inlineIndent: seamlessIndentMarker,
      );
    }

    final inferredIndent = explicitProperty.indentOnExit;
    final hasIndent = inferredIndent != null;

    /// If equal then we are at the same level as a "?" or ":" on a new line.
    /// Anything we moved back a level/several
    if (hasIndent && inferredIndent <= parentIndent) {
      return (
        shouldExit: true,
        hasIndent: hasIndent,
        parsedProperty: explicitProperty,
        inferredIndent: inferredIndent,
        laxIndent: inferredIndent,
        inlineIndent: inferredIndent,
      );
    }

    final (:laxIndent, :inlineFixedIndent) = _blockChildIndent(
      inferredIndent,
      blockParentIndent: parentIndent,
      startOffset: startOffset,
    );

    return (
      shouldExit: false,
      hasIndent: hasIndent,
      parsedProperty: explicitProperty,
      inferredIndent: inferredIndent,
      laxIndent: laxIndent,
      inlineIndent: inlineFixedIndent,
    );
  }

  /// Parses an explicit key. This function is always called by
  /// [_parseExplicitBlockEntry]. You should never call it directly unless
  /// you only need the key!
  (bool shouldExit, _BlockNodeInfo info, ParserDelegate key)
  _parseExplicitBlockKey({required int indentLevel, required int mapIndent}) {
    final keyOffset = _scanner.lineInfo().current;

    final (
      :shouldExit,
      hasIndent: preKeyHasIndent,
      :inferredIndent,
      :parsedProperty,
      :laxIndent,
      :inlineIndent,
    ) = _explicitIsParsable(
      keyOffset.utfOffset,
      mapIndent,
    );

    if (shouldExit && !parsedProperty.isAlias) {
      final lineInfo = _scanner.lineInfo();

      // We have an empty/null key on our hands
      return (
        !preKeyHasIndent || inferredIndent! < mapIndent,
        (exitIndent: inferredIndent, docMarker: DocumentMarker.none),

        _trackAnchor(
          nullScalarDelegate(
              indentLevel: indentLevel,
              indent: mapIndent,
              startOffset: keyOffset,
            )
            ..updateEndOffset = preKeyHasIndent
                ? lineInfo.start
                : lineInfo.current,
          parsedProperty,
        ),
      );
    }

    /// Our key can either have:
    ///   - Null indent which indicates that the key is declared on the same
    ///     line with the indicator.
    ///   - A larger indent indicates the element is more indented than the
    ///     indicator.
    ///
    /// We don't care (because we don't know how differentiate this). Let the
    /// block node function determine where these indents fit in our grand
    /// scheme of things.
    final (:nodeInfo, :delegate) = _parseBlockNode(
      startOffset: keyOffset,
      indentLevel: indentLevel,
      laxIndent: laxIndent,
      fixedInlineIndent: inlineIndent,
      forceInlined: false,
      isParsingKey: true,
      isExplicitKey: true,
      degenerateToImplicitMap: true,
      parentEnforcedCompactness: false,
      blockNodeProperty: parsedProperty,
    );

    final (:exitIndent, :docMarker) = nodeInfo;

    final hasIndent = exitIndent != null;

    /// Parsing YAML makes you a skeptic with the layout restrictions.
    ///
    /// A ":" must be declared on a new line while being aligned with the
    /// "?" that triggered this key to be parsed. Thus, their indents
    /// *MUST* match.
    if (!hasIndent && _scanner.canChunkMore) {
      // This error is rare must be accounted for!
      throwWithSingleOffset(
        _scanner,
        message:
            'Expected ":" on a new line with an indent of $mapIndent'
            ' space(s) but found null',
        offset: _scanner.lineInfo().current,
      );
    } else if (hasIndent && exitIndent > mapIndent) {
      throwWithApproximateRange(
        _scanner,
        message:
            'Expected indent of $mapIndent space(s) but found $exitIndent'
            ' space(s)',
        current: _scanner.lineInfo().current,
        charCountBefore: exitIndent,
      );
    }

    return (
      /// We can exit early if we are no longer at the current map's level
      /// based on the indent (the current map is the caller of this function)
      /// or the current document ended.
      docMarker.stopIfParsingDoc || !hasIndent || exitIndent < mapIndent,
      nodeInfo,
      delegate,
    );
  }

  /// Parses an explicit block map entry within a block collection declared
  /// using the `?` character.
  _BlockEntry _parseExplicitBlockEntry({
    required int indentLevel,
    required int indent,
  }) {
    // Must have explicit key indicator
    if (inferNextEvent(
          _scanner,
          isBlockContext: true,
          lastKeyWasJsonLike: false,
        ) !=
        BlockCollectionEvent.startExplicitKey) {
      throwWithSingleOffset(
        _scanner,
        message: 'Expected an explicit key indicator "?"',
        offset: _scanner.lineInfo().current,
      );
    }

    final childIndentLevel = indentLevel + 1;

    // Attempt to parse key
    final (exitAfterKey, keyNodeInfo, explicitKey) = _parseExplicitBlockKey(
      indentLevel: childIndentLevel,
      mapIndent: indent,
    );

    _blockNodeInfoEndOffset(explicitKey, scanner: _scanner, info: keyNodeInfo);

    if (exitAfterKey) {
      return (
        nodeInfo: keyNodeInfo,
        delegate: (key: explicitKey, value: null),
      );
    }

    /// At this point, we may be parsing a new node or the value of this
    /// explicit key since block nodes have no indicators. Ensure this is the
    /// case.
    if (inferNextEvent(
          _scanner,
          isBlockContext: true,
          lastKeyWasJsonLike: false,
        ) !=
        BlockCollectionEvent.startEntryValue) {
      return (
        delegate: (key: explicitKey, value: null),
        nodeInfo: (exitIndent: indent, docMarker: DocumentMarker.none),
      );
    }

    final valueOffset = _scanner.lineInfo().current;

    // Check if we can parse the value
    final (
      :shouldExit,
      :hasIndent,
      :inferredIndent,
      :parsedProperty,
      :laxIndent,
      :inlineIndent,
    ) = _explicitIsParsable(
      valueOffset.utfOffset,
      indent,
    );

    /// No need to parse the value if we moved to the next line and the
    /// indent matches. Usually means there is no value to parse
    if (shouldExit) {
      ParserDelegate? val;

      if (_nullOrAlias(
            parsedProperty,
            indentLevel: indentLevel,
            indent: indent,
            start: valueOffset,
            end: _determineBlockEndOffset(
              _scanner,
              hasDocEndMarkers: false,
              indentOnExit: inferredIndent,
            ),
          )
          case ParserDelegate nullOrAlias) {
        val = nullOrAlias;
      }

      return (
        nodeInfo: (
          exitIndent: inferredIndent,
          docMarker: DocumentMarker.none,
        ),
        delegate: (key: explicitKey, value: val),
      );
    }

    final (:delegate, :nodeInfo) = _parseBlockNode(
      startOffset: valueOffset,
      indentLevel: childIndentLevel,
      laxIndent: laxIndent,
      fixedInlineIndent: inlineIndent,
      forceInlined: false,
      isParsingKey: false,
      isExplicitKey: false,
      degenerateToImplicitMap: true,
      parentEnforcedCompactness: false,
      blockNodeProperty: parsedProperty,
    );

    _blockNodeInfoEndOffset(delegate, scanner: _scanner, info: nodeInfo);
    return (delegate: (key: explicitKey, value: delegate), nodeInfo: nodeInfo);
  }

  _ImplicitBlockValue _parseImplicitBlockValue({
    required int parentIndent,
    required int parentIndentLevel,
    required RuneOffset valueOffset,
    required ParserEvent Function() eventCallback,
  }) {
    _scanner.skipCharAtCursor(); // Skip ":"
    var indentOrSeparation = skipToParsableChar(_scanner, comments: _comments);

    final minValueIndent = parentIndent + 1;
    final valueIndentLevel = parentIndentLevel + 1;

    var childEvent = eventCallback();

    /// This is not similar to the [valueOffset]. YAML indicates a value starts
    /// when the ":" is seen; which is fine. However, the node's alignment with
    /// subsequent siblings (in case this node becomes an implicit map) depends
    /// on where it actually starts. Such that:
    ///
    /// key: value
    ///    ^^^ It starts in the first caret but it's alignment must start at "v"
    ///
    /// Now see below:
    ///
    /// ```yaml
    /// key:
    ///   nested: implicit-block-map-as-value
    ///   another: nested
    /// another:
    ///   !!tag key: value
    /// ```
    ///
    /// Our argument is now evident. Our actual content offset starts when we
    /// see the first parsable char. Serves no purpose now but maybe
    /// later?
    ///
    /// TODO: Dumper & editor see this 🧙🏽‍♂️. Explicit too
    final contentOffset = _scanner.lineInfo().current;

    ParsedProperty? valueProperty;

    if (childEvent is NodePropertyEvent) {
      valueProperty = parseNodeProperties(
        _scanner,
        minIndent: minValueIndent,
        resolver: _resolveTag,
        comments: _comments,
      );

      indentOrSeparation = valueProperty.indentOnExit;
      childEvent = eventCallback();
    }

    valueProperty ??= ParsedProperty.empty(
      contentOffset,
      contentOffset,
      indentOrSeparation,
      spanMultipleLines: indentOrSeparation != null,
    );

    /// Coin toss. We either have a null value or it's an alias if we
    /// have any props :)

    if (!_scanner.canChunkMore) {
      return (
        delegate: _nullOrAlias(
          valueProperty,
          indentLevel: valueIndentLevel,
          indent: minValueIndent,
          start: valueOffset,
          end: _scanner.lineInfo().current,
        ),
        nodeInfo: _emptyScanner,
      );
    }

    final isBlockList = childEvent == BlockCollectionEvent.startBlockListEntry;

    /// YAML 1.2 recommends grace for block lists that start on a new line but
    /// have the same indent as the implicit key since the "-" is usually
    /// perceived as indent.
    if (valueProperty.isMultiline) {
      if (indentOrSeparation != null &&
          ((indentOrSeparation == parentIndent && !isBlockList) ||
              (indentOrSeparation < parentIndent))) {
        return (
          delegate: _nullOrAlias(
            valueProperty,
            indentLevel: valueIndentLevel,
            indent: minValueIndent,
            start: valueOffset,
            end: _scanner.lineInfo().start,
          ),
          nodeInfo: (
            docMarker: DocumentMarker.none,
            exitIndent: indentOrSeparation,
          ),
        );
      }
    } else if (!valueProperty.parsedAny &&
        (isBlockList || childEvent == BlockCollectionEvent.startExplicitKey)) {
      throwWithRangedOffset(
        _scanner,
        message:
            'The block collections must start on a new line when used as '
            'values of an implicit key',
        start: valueOffset,
        end: _scanner.lineInfo().current,
      );
    }

    var marker = DocumentMarker.none;
    int? indentOnExit;
    ParserDelegate? value;

    if (valueProperty is Alias) {
      value =
          _referenceAlias(
              valueProperty,
              indentLevel: valueIndentLevel,
              indent: minValueIndent,
              start: valueOffset,
            )
            ..updateEndOffset = _scanner.lineInfo().start
            ..updateNodeProperties = valueProperty;

      /// Alias will use the indent that was inferred when the alias itself
      /// was parsed. Let the parser determine the next course of action at the
      /// map level.
      indentOnExit = indentOrSeparation;
    } else {
      final (:laxIndent, :inlineFixedIndent) = _blockChildIndent(
        indentOrSeparation,
        blockParentIndent: parentIndent,
        startOffset: contentOffset.utfOffset,
      );

      final (
        :delegate,
        nodeInfo: _BlockNodeInfo(:docMarker, :exitIndent),
      ) = _parseBlockNode(
        startOffset: valueOffset,
        indentLevel: valueIndentLevel,
        laxIndent: laxIndent,
        fixedInlineIndent: inlineFixedIndent,
        forceInlined: false,
        isParsingKey: false,
        isExplicitKey: false,
        degenerateToImplicitMap: valueProperty.isMultiline, // If not inline
        parentEnforcedCompactness: false,
        blockNodeProperty: valueProperty,
        event: childEvent,
      );

      value = delegate;
      marker = docMarker;
      indentOnExit = exitIndent;
    }

    /// Implicit values exit immediately a line break is seen but do not skip
    /// it. However, the block parent (map) needs to have the correct indent
    /// info to prevent any premature termination before subsequent nodes can
    /// be parsed.
    if (_scanner.charAtCursor case lineFeed || carriageReturn || space || tab
        when _scanner.canChunkMore &&
            !marker.stopIfParsingDoc &&
            indentOnExit == seamlessIndentMarker) {
      indentOnExit = skipToParsableChar(_scanner, comments: _comments);
    }

    return (
      delegate: value,
      nodeInfo: (exitIndent: indentOnExit, docMarker: marker),
    );
  }

  /// Parses an implicit block map entry within a block collection.
  _BlockEntry _parseImplicitBlockEntry(
    ParserDelegate? key, {
    required int parentIndent,
    required int parentIndentLevel,
    required ParsedProperty keyProperty,
    ParserEvent? mapEvent,
  }) {
    ParserEvent nextEvent() => inferNextEvent(
      _scanner,
      isBlockContext: true,
      lastKeyWasJsonLike: false,
    );

    var implicitKey = key;

    /// We should never see a block collection event for an explicit key/
    /// block list as implicit keys are restricted to a single line
    final event = mapEvent ?? nextEvent();

    if (event
        case BlockCollectionEvent.startBlockListEntry ||
            BlockCollectionEvent.startExplicitKey) {
      throwWithSingleOffset(
        _scanner,
        message:
            'Implicit keys are restricted to a single line. Consider using an'
            ' explicit key for the entry',
        offset: _scanner.lineInfo().current,
      );
    }

    if (key == null && event != BlockCollectionEvent.startEntryValue) {
      final keyStart = keyProperty.span.start;

      final (:delegate, :nodeInfo) = _parseBlockNode(
        startOffset: keyStart,
        event: event,
        indentLevel: parentIndentLevel,
        laxIndent: parentIndent, // Key is the parent's contact in this entry
        fixedInlineIndent: parentIndent,
        forceInlined: true,
        isParsingKey: true,
        isExplicitKey: false,
        degenerateToImplicitMap: false,
        parentEnforcedCompactness: false,

        /// Callers of this [_parseImplicitBlockEntry] function must correctly
        /// handle its node properties. Usually, implicit maps are tightly
        /// controlled. This is evident when:
        ///   1. Parsing block keys - Cannot span multiple lines
        ///   2. Compact notation prevents the implicit maps nested in
        ///      block sequences and explicit block keys from having node
        ///      properties
        ///
        /// Ergo, the callers should never call the [_parseImplicitBlockEntry]
        /// directly unless via [_parseBlockMap] or [_parseBlockNode]. If they
        /// do, they must handle the node properties ahead of time!
        blockNodeProperty: ParsedProperty.empty(
          keyStart,
          keyStart,
          parentIndent,
          spanMultipleLines: false,
        ),
      );

      final (:docMarker, :exitIndent) = nodeInfo;

      /// The exit indent *MUST* be null or be seamless (parsed completely with
      /// no indent change if quoted). This is a key that should *NEVER*
      /// spill into the next line.
      if (exitIndent != null && exitIndent != seamlessIndentMarker) {
        throwWithApproximateRange(
          _scanner,
          message: 'Implicit keys cannot have an exit indent',
          current: _scanner.lineInfo().current,
          charCountBefore: exitIndent,
        );
      }

      // This was never a key. We assumed it was a plain scalar and parsed it.
      if (delegate case ScalarDelegate(
        preScalar: PreScalar(
          scalarStyle: ScalarStyle.plain,
          :final content, // TODO: Iffy on this. Add test for this
        ),
      ) when docMarker.stopIfParsingDoc && content.isEmpty) {
        return (nodeInfo: nodeInfo, delegate: (key: null, value: null));
      }

      implicitKey = delegate;
    }

    // Must declare ":" on the same line
    if (skipToParsableChar(_scanner, comments: _comments) != null ||
        nextEvent() != BlockCollectionEvent.startEntryValue) {
      throwWithSingleOffset(
        _scanner,
        message: 'Expected a ":" (after the key)',
        offset: _scanner.lineInfo().current,
      );
    }

    final valueOffset = _scanner.lineInfo().current;

    implicitKey ??= nullScalarDelegate(
      indentLevel: parentIndentLevel,
      indent: parentIndent,
      startOffset: valueOffset,
    );

    implicitKey.updateEndOffset = valueOffset;
    _trackAnchor(implicitKey, keyProperty);

    final (:delegate, :nodeInfo) = _parseImplicitBlockValue(
      parentIndent: parentIndent,
      parentIndentLevel: parentIndentLevel,
      valueOffset: valueOffset,
      eventCallback: nextEvent,
    );

    return (delegate: (key: implicitKey, value: delegate), nodeInfo: nodeInfo);
  }

  /// Throws if a block node is declared with an indent that is greater than
  /// the block parent's indent but less than the indent of the first child of
  /// the block
  (RuneOffset? offset, ParsedProperty? property) _throwIfDangling(
    int collectionIndent,
    int currentIndent, {
    required bool allowProperties,
  }) {
    final isNodeEvent =
        inferNextEvent(
              _scanner,
              isBlockContext: true,
              lastKeyWasJsonLike: false,
            )
            is NodePropertyEvent;

    if (currentIndent > collectionIndent && _scanner.canChunkMore) {
      throwWithApproximateRange(
        _scanner,
        message:
            'Dangling node/node properties found with indent of $currentIndent'
            ' space(s) while parsing',
        current: _scanner.lineInfo().current,
        charCountBefore: currentIndent,
      );
    } else if (isNodeEvent) {
      if (!allowProperties) {
        throwWithApproximateRange(
          _scanner,
          message: 'Dangling node properties are not allowed here',
          current: _scanner.lineInfo().current,
          charCountBefore: currentIndent,
        );
      }

      final offset = _scanner.lineInfo().current;

      return (
        offset,
        parseNodeProperties(
          _scanner,
          minIndent: collectionIndent + 1,
          resolver: _resolveTag,
          comments: _comments,
        ),
      );
    }

    return (null, null);
  }

  /// Parses a block map. If [firstImplicitKey] is present, the map parses
  /// only the value of the first key.
  _BlockNodeInfo _parseBlockMap(
    MappingDelegate map,
    ParserDelegate? firstImplicitKey,
    ParsedProperty? parsedProperty,
  ) {
    var parsedKey = firstImplicitKey;
    final MappingDelegate(:indent, :indentLevel) = map;

    ParsedProperty nonNull(ParsedProperty? current, RuneOffset onNull) {
      if (current != null) return current;
      return ParsedProperty.empty(
        onNull,
        onNull,
        indent,
        spanMultipleLines: false,
      );
    }

    var properties = parsedProperty;
    RuneOffset? implicitStartOffset;

    void resetProps(ParsedProperty? props, RuneOffset? offset) {
      properties = props;
      implicitStartOffset = offset;
    }

    void throwIfDanglingProps() {
      if (properties != null) {
        final (:start, :end) = properties!.span;

        throwWithRangedOffset(
          _scanner,
          message: 'Dangling node properties found while exiting block map',
          start: start,
          end: end,
        );
      }
    }

    while (_scanner.canChunkMore) {
      ParserDelegate? key;
      ParserDelegate? value;
      _BlockNodeInfo mapInfo;

      final nodeProps = nonNull(
        properties,
        implicitStartOffset ?? _scanner.lineInfo().current,
      );

      final (
        :event,
        :hasProperties,
        :blockMapContinue,
        :isExplicitEntry,
        :indentOnExit,
      ) = _checkMapState(
        nodeProps,
        isBlockContext: true,
        minMapIndent: indent,
      );

      if (!blockMapContinue) {
        throwForCurrentLine(
          _scanner,
          message: 'Block map found in a unparsable state',
        );
      }

      if (isExplicitEntry) {
        final (:delegate, :nodeInfo) = _parseExplicitBlockEntry(
          indentLevel: indentLevel,
          indent: indent,
        );

        mapInfo = nodeInfo;
        key = delegate.key;
        value = delegate.value;
      } else {
        parsedKey ??= _aliasKeyOrNull(
          nodeProps,
          indentLevel: indentLevel,
          indent: indent,
          keyStartOffset: nodeProps.span.start,
          existing: parsedKey,
        );

        final (:delegate, :nodeInfo) = _parseImplicitBlockEntry(
          parsedKey,
          parentIndent: indent,
          parentIndentLevel: indentLevel,
          keyProperty: nodeProps,
          mapEvent: event,
        );

        mapInfo = nodeInfo;
        key = delegate.key;
        value = delegate.value;
      }

      /// Most probably encountered doc end chars while parsing implicit map.
      /// An explicit key should never return null here
      if (key == null) {
        throwIfDanglingProps();
        _blockNodeInfoEndOffset(map, scanner: _scanner, info: mapInfo);
        return mapInfo;
      }

      if (!map.pushEntry(key, value)) {
        _onMapDuplicate(
          key.start,
          value?.start ?? _scanner.lineInfo().current,
          'Block map cannot contain entries sharing the same key',
        );
      }

      final (:docMarker, :exitIndent) = mapInfo;
      final hasDocEndMarkers = docMarker.stopIfParsingDoc;

      /// Update end offset. We must always have the correct end offset
      /// independent of the last node.
      _blockNodeEndOffset(
        map,
        scanner: _scanner,
        hasDocEndMarkers: hasDocEndMarkers,
        indentOnExit: exitIndent,
      );

      if (hasDocEndMarkers) {
        return mapInfo;
      }

      /// If no doc end chars were found, indent on exit *MUST* not be null.
      /// Block collections rely only on indent as delimiters
      if (exitIndent == null) {
        if (_scanner.canChunkMore) {
          throwWithSingleOffset(
            _scanner,
            message: 'Invalid map entry found at while parsing block map',
            offset: _scanner.lineInfo().current,
          );
        }

        resetProps(null, null);
        break;
      } else if (exitIndent < indent) {
        return mapInfo;
      }

      // Must not have a dangling indent or properties at this point
      final (indentOnProps, props) = _throwIfDangling(
        indent,
        exitIndent,
        allowProperties: true,
      );

      resetProps(props, indentOnProps);
      parsedKey = null;
    }

    throwIfDanglingProps();
    return _emptyScanner;
  }

  /// Parses a block sequence entry
  _BlockNode _parseBlockSequenceEntry({
    required int indentLevel,
    required int laxIndent,
    required int fixedInlineIndent,
    required bool forceInlined,
    required bool isParsingKey,
    required bool isExplicitKey,
    required bool enforceCompactness,
    required RuneOffset startOffset,
    required ParsedProperty entryProperty,
  }) {
    final sequenceInfo = _parseBlockNode(
      startOffset: startOffset,
      indentLevel: indentLevel,
      laxIndent: laxIndent,
      fixedInlineIndent: fixedInlineIndent,
      forceInlined: false,
      isParsingKey: false,
      isExplicitKey: false,
      degenerateToImplicitMap: true,
      parentEnforcedCompactness: enforceCompactness,
      blockNodeProperty: entryProperty,
    );

    if (sequenceInfo.delegate case AliasDelegate alias
        when !entryProperty.isMultiline &&
            inferNextEvent(
                  _scanner,
                  isBlockContext: true,
                  lastKeyWasJsonLike: false,
                ) ==
                BlockCollectionEvent.startEntryValue) {
      return _parseWildcardBlockMap(
        alias..updateEndOffset = _scanner.lineInfo().current,
        mapIndentLvel: indentLevel,
        mapFixedIndent: fixedInlineIndent,
        keyProperty: ParsedProperty.empty(
          entryProperty.span.start,
          entryProperty.span.end,
          null,
          spanMultipleLines: false,
        ),
        parentEnforcedCompactness: false,
      );
    }

    return sequenceInfo;
  }

  /// Parses a block sequence.
  _BlockNodeInfo _parseBlockSequence(SequenceDelegate sequence) {
    final SequenceDelegate(:indent, :indentLevel) = sequence;

    DocumentMarker? exitOrThrowIfNotBlock() {
      final char = _scanner.charAtCursor;
      final charAfter = _scanner.charAfter;

      switch (char) {
        /// Be gracious. Maybe we have doc end chars here.
        ///
        /// TODO: Remove zero indent for doc end chars? Mulling 🤔
        /// TODO: Should doc end chars hug left or just have any indent?
        case blockSequenceEntry || period when indent == 0 && charAfter == char:
          {
            if (checkForDocumentMarkers(_scanner, onMissing: (_) {})
                case DocumentMarker docType when docType.stopIfParsingDoc) {
              return docType;
            }

            continue invalid;
          }

        // Normal "- " combination for block list
        case blockSequenceEntry
            when charAfter.isNullOr((c) => c.isWhiteSpace() || c.isLineBreak()):
          return null;

        invalid:
        default:
          throwWithSingleOffset(
            _scanner,
            message: 'Expected a "- " while parsing sequence entry',
            offset: _scanner.lineInfo().current,
          );
      }
    }

    final childIndentLevel = indentLevel + 1;

    /// Always want it run the first time. We need that first empty node
    /// with the "-<null>" pattern
    do {
      if (exitOrThrowIfNotBlock() case DocumentMarker docMarkerType) {
        return (docMarker: docMarkerType, exitIndent: null);
      }

      final startOffset = _scanner.lineInfo().current;

      _scanner.skipCharAtCursor(); // Skip "-"

      var indentOrSeparation = skipToParsableChar(
        _scanner,
        onParseComment: _comments.add,
      );

      final entryProperty = parseNodeProperties(
        _scanner,
        minIndent: indentOrSeparation ?? indent + 1,
        resolver: _resolveTag,
        comments: _comments,
      );

      if (!_scanner.canChunkMore) {
        if (entryProperty.parsedAny) {
          sequence.pushEntry(
            _nullOrAlias(
              entryProperty,
              indentLevel: childIndentLevel,
              indent: indent + 1,
              start: startOffset,
              end: entryProperty.span.end,
            )!,
          );
        }

        break;
      }

      final enforceCompactness = indentOrSeparation == null;

      if (entryProperty.indentOnExit case int exitIndent) {
        indentOrSeparation = exitIndent;
      }

      if (indentOrSeparation != null) {
        final isLess = indentOrSeparation < indent;

        // We moved to the next node irrespective of its indent.
        if (isLess || indentOrSeparation == indent) {
          final end = _scanner.lineInfo().start;

          final entry =
              _nullOrAlias(
                      entryProperty,
                      indentLevel: indentLevel,
                      indent: indent,
                      start: startOffset,
                      end: end,
                    ) ??
                    nullScalarDelegate(
                      indentLevel: childIndentLevel,
                      indent: indent + 1,
                      startOffset: startOffset,
                    )
                ..updateEndOffset = end;

          sequence.pushEntry(entry);

          // Not a skill issue. 2 birds, 1 stone
          if (isLess) {
            return (
              exitIndent: indentOrSeparation,
              docMarker: DocumentMarker.none,
            );
          }

          continue;
        }
      }

      // Determine indentation of child node
      final (:laxIndent, :inlineFixedIndent) = _blockChildIndent(
        indentOrSeparation,
        blockParentIndent: indent,
        startOffset: startOffset.utfOffset,
      );

      final (:delegate, :nodeInfo) = _parseBlockSequenceEntry(
        startOffset: startOffset,
        indentLevel: childIndentLevel,
        laxIndent: laxIndent,
        fixedInlineIndent: inlineFixedIndent,
        forceInlined: false,
        isParsingKey: false,
        isExplicitKey: false,
        enforceCompactness: enforceCompactness,
        entryProperty: entryProperty,
      );

      sequence.pushEntry(delegate);

      final (:docMarker, :exitIndent) = nodeInfo;
      final hasDocEndMarkers = docMarker.stopIfParsingDoc;

      // Update offset of sequence. May span more than the last node
      _blockNodeEndOffset(
        sequence,
        scanner: _scanner,
        hasDocEndMarkers: hasDocEndMarkers,
        indentOnExit: exitIndent,
      );

      if (hasDocEndMarkers) return nodeInfo;

      /// If no doc end chars were never found, indent on exit *MUST* not be
      /// null. Block collections rely only on indent as delimiters
      if (exitIndent == null) {
        if (_scanner.canChunkMore) {
          throwWithSingleOffset(
            _scanner,
            message: 'Invalid block list entry',
            offset: _scanner.lineInfo().current,
          );
        }

        break;
      } else if (exitIndent < indent) {
        return nodeInfo;
      }

      // Must not have a dangling indent at this point
      _throwIfDangling(indent, exitIndent, allowProperties: false);
    } while (_scanner.canChunkMore);

    return _emptyScanner;
  }

  /// Parses the next [YamlDocument] if present in the YAML string.
  ///
  /// `NOTE:` This advances the parsing forward and holds no reference to a
  /// previously parsed [YamlDocument].
  YamlDocument? parseNext() {
    _restartParser();

    if (!_scanner.canChunkMore) return null;

    YamlDirective? version;
    var tags = <TagHandle, GlobalTag>{};
    var reserved = <ReservedDirective>[];

    _docStartExplicit = _lastWasDocEndChars == '---';

    // If no directives end indicator, parse directives
    if (!_docStartExplicit) {
      final (
        :yamlDirective,
        :globalTags,
        :reservedDirectives,
        :hasDirectiveEnd,
      ) = parseDirectives(
        _scanner,
        onParseComment: _comments.add,
        warningLogger: (message) => _logger(false, message),
      );

      _hasDirectives =
          yamlDirective != null ||
          globalTags.isNotEmpty ||
          reservedDirectives.isNotEmpty;

      /// When directives are absent, we may see dangling "---". Just to be
      /// sure, confirm this wasn't the case.
      if (!hasDirectiveEnd &&
          _scanner.charAtCursor == blockSequenceEntry &&
          _scanner.charAfter == blockSequenceEntry) {
        final startOnMissing = _scanner.lineInfo().current;

        _docStartExplicit =
            checkForDocumentMarkers(
              _scanner,
              onMissing: (c) {
                _docMarkerGreedy = (
                  start: startOnMissing,
                  greedChars: c.map((e) => e.asString()).join(),
                );
              },
            ) ==
            DocumentMarker.directiveEnd;
      } else {
        _docStartExplicit = hasDirectiveEnd;
      }

      version = yamlDirective;
      tags = globalTags;
      reserved = reservedDirectives;
    }

    // YAML allows the secondary tag to be declared with custom global tag
    _globalTags.addAll(tags);

    const rootIndentLevel = 0;

    /// Why block info? YAML clearly has a favourite child and that is the
    /// block(-like) styles. They are indeed a human friendly format. Also, the
    /// doc end chars "..." and "---" exist in this format.
    ParserDelegate? root;
    _BlockNodeInfo? rootInfo;

    /// If we attempted to check for doc markers and found none
    if (_docMarkerGreedy != null) {
      final (:start, :greedChars) = _docMarkerGreedy!;

      final (:delegate, :nodeInfo) = _parseBlockScalarWildcard(
        ScalarEvent.startFlowPlain,
        startOffset: start,
        laxIndent: 0,
        fixedIndent: 0,
        indentLevel: rootIndentLevel,
        isInlined: false,
        degenerateToImplicitMap: true,
        parentEnforcedCompactness: false,
        scalarProperty: ParsedProperty.empty(
          start,
          start,
          0,
          spanMultipleLines: false,
        ),
        greedOnPlain: greedChars,
      );

      root = delegate;
      rootInfo = nodeInfo;
    } else {
      _rootInMarkerLine = _docIsInMarkerLine(
        _scanner,
        isDocStartExplicit: _docStartExplicit,
      );

      var rootIndent = skipToParsableChar(_scanner, comments: _comments);
      final rootStartOffset = _scanner.lineInfo().current;

      _throwIfUnsafeForDirectiveChar(
        _scanner,
        indent: rootIndent ?? 0,
        hasDirectives: _hasDirectives,
      );

      ParsedProperty? rootProperty;

      var rootEvent = inferNextEvent(
        _scanner,
        isBlockContext: true, // Always prefer block styling over flow
        lastKeyWasJsonLike: false,
      );

      if (rootEvent is NodePropertyEvent) {
        rootProperty = parseNodeProperties(
          _scanner,

          // Default to "-1" if we have no node in place.
          minIndent: rootIndent ?? -1,
          resolver: _resolveTag,
          comments: _comments,
        );

        if (rootProperty.isAlias) {
          throwWithRangedOffset(
            _scanner,
            message: 'Root node cannot be an alias!',
            start: rootProperty.span.start,
            end: rootProperty.span.end,
          );
        }

        rootEvent = inferNextEvent(
          _scanner,
          isBlockContext: true,
          lastKeyWasJsonLike: false,
        );

        rootIndent = rootProperty.indentOnExit;
      }

      rootProperty ??= ParsedProperty.empty(
        rootStartOffset,
        rootStartOffset,
        null,
        spanMultipleLines: false,
      );

      rootIndent ??= 0; // Defaults to zero if null

      final (:delegate, :nodeInfo) = _parseBlockNode(
        event: rootEvent,
        startOffset: rootStartOffset,
        indentLevel: rootIndentLevel,
        laxIndent: rootIndent,
        fixedInlineIndent: rootIndent,
        forceInlined: false,
        isParsingKey: false, // No effect if explicit. Handled
        isExplicitKey: false,
        degenerateToImplicitMap: !_rootInMarkerLine,
        parentEnforcedCompactness: false,
        blockNodeProperty: rootProperty,
      );

      root = delegate;
      rootInfo = nodeInfo;
    }

    var docMarker = DocumentMarker.none;

    if (_scanner.canChunkMore) {
      /// We must see document end chars and don't care how they are laid within
      /// the document. At this point the document is or should be complete
      if (!rootInfo.docMarker.stopIfParsingDoc) {
        skipToParsableChar(_scanner, comments: _comments);

        // We can safely look for doc end chars
        if (_scanner.canChunkMore) {
          var charBehind = 0;
          docMarker = checkForDocumentMarkers(
            _scanner,
            onMissing: (b) => charBehind = b.length,
          );

          if (!docMarker.stopIfParsingDoc) {
            throwWithApproximateRange(
              _scanner,
              message:
                  'Expected to find document end chars "..." or directive end '
                  'chars "---" ',
              current: _scanner.lineInfo().current,
              charCountBefore: _scanner.canChunkMore
                  ? max(charBehind - 1, 0)
                  : charBehind,
            );
          }
        }

        final sourceInfo = _scanner.lineInfo();

        root.updateEndOffset = docMarker.stopIfParsingDoc
            ? sourceInfo.start
            : sourceInfo.current;
      } else {
        docMarker = rootInfo.docMarker;
      }
    } else {
      docMarker = rootInfo.docMarker;
    }

    _updateDocEndChars(docMarker);

    return YamlDocument._(
      _currentIndex,
      version,
      tags.values.toSet(),
      reserved,
      _comments,
      root.parsed(),
      YamlDocType.inferType(
        hasDirectives: _hasDirectives,
        isDocStartExplicit: _docStartExplicit,
      ),
      _docStartExplicit,
      _docEndExplicit,
    );
  }
}
