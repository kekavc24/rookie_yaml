import 'package:rookie_yaml/src/parser/delegates/parser_delegate.dart';
import 'package:rookie_yaml/src/parser/directives/directives.dart';
import 'package:rookie_yaml/src/parser/document/node_properties.dart';
import 'package:rookie_yaml/src/parser/parser_utils.dart';
import 'package:rookie_yaml/src/scanner/grapheme_scanner.dart';
import 'package:rookie_yaml/src/scanner/source_iterator.dart';
import 'package:rookie_yaml/src/schema/nodes/yaml_node.dart';
import 'package:rookie_yaml/src/schema/yaml_comment.dart';
import 'package:rookie_yaml/src/schema/yaml_schema.dart';

final _defaultGlobalTag = MapEntry(TagHandle.secondary(), yamlGlobalTag);

/// A map with functions linked to a tag suffix
typedef Resolvers = Map<TagShorthand, ResolverCreator>;

/// A callback for handling map duplicates
typedef MapDuplicateHandler =
    void Function(RuneOffset keyStart, RuneOffset keyEnd, String message);

/// Logger callback
typedef ParserLogger = void Function(bool isInfo, String message);

/// Represents the kind of node to be parsed
enum NodeKind {
  /// [Scalar]
  scalar,

  /// [Set] or [Sequence] with unique elements
  set,

  /// Normal [Sequence] or [List]
  sequence,

  /// [Mapping] or [Map]
  mapping,

  /// A node whose kind could not be determined from the available information.
  /// This usually instructs the parser to use a [ParserEvent] instead.
  unknown,
}

/// [ResolvedTag] and the [NodeKind] represented by the tag.
typedef OnTagResolved = ({ResolvedTag tag, NodeKind kind});

/// A tag resolver callback
typedef TagResolver =
    OnTagResolved Function(RuneOffset start, RuneOffset end, TagShorthand tag);

/// Holds the document parser's top level state
final class ParserState<R, S extends Iterable<R>, M extends Map<R, R?>> {
  ParserState(
    this.scanner, {
    required this.aliasFunction,
    required this.listFunction,
    required this.mapFunction,
    required this.scalarFunction,
    required this.logger,
    required this.onMapDuplicate,
    List<Resolver>? resolvers,
  }) : _resolvers = (resolvers ?? []).fold({}, (p, c) {
         final Resolver(:target, :creator) = c;
         p[target] = creator;
         return p;
       });

  /// Scanner with source string
  final GraphemeScanner scanner;

  /// Alias builder
  final AliasFunction<R> aliasFunction;

  /// Sequence builder
  final ListFunction<R, S> listFunction;

  /// Map builder
  final MapFunction<R, M> mapFunction;

  /// Scalar builder
  final ScalarFunction<R> scalarFunction;

  /// Custom functions to resolve a node
  final Resolvers _resolvers;

  /// Logging function for warnings and info
  final ParserLogger logger;

  /// Callback used to report keys that are duplicates in flow/block maps
  final MapDuplicateHandler onMapDuplicate;

  /// Global directives.
  ///
  /// Secondary tag always resolves
  final globalTags = Map.fromEntries([_defaultGlobalTag]);

  /// Index of document being parsed
  int _currentIndex = -1;

  /// Index of document being parsed
  int get current => _currentIndex;

  /// Char sequence that terminated the last document.
  ///
  /// If `...`, the parser looks for directives first before parsing can
  /// start until an explicit `---` is encountered. Throws an error otherwise.
  ///
  /// If `---`, the parser starts parsing nodes immediately. This also limits
  /// the use of `%` as the first character for plain style-like nodes, that is,
  /// [ScalarStyle.plain], [ScalarStyle.literal] and [ScalarStyle.folded]. The
  /// character cannot be used if the indent level is `0`.
  String lastDocEndChars = '';

  /// Tracks if the current document has an explicit start.
  ///
  /// End of directives. `---` at beginning.
  bool docStartExplicit = false;

  /// Tracks if last document had an explicit end.
  ///
  /// `...` at the end.
  bool docEndExplicit = false;

  /// Tracks whether the root node start on the same line as the directives
  /// end marker (`---`).
  bool rootInMarkerLine = false;

  /// Tracks whether any directives were declared
  bool hasDirectives = false;

  /// Tracks anchors that can be used as aliases
  final _anchorNodes = <String, R>{};

  /// Buffers all parsed comments
  var comments = <YamlComment>[];

  /// Tracks the object [R] generated by the [delegate] if [property] is not
  /// null and anchor is present.
  T trackAnchor<T extends ParserDelegate>(
    T delegate,
    ParsedProperty? property,
  ) {
    delegate.updateNodeProperties = property;

    if (property case NodeProperty(:final String anchor)) {
      _anchorNodes[anchor] = delegate.parsed();
    }

    return delegate;
  }

  /// Returns an [AliasDelegate] if [alias] has a corresponding anchor.
  /// Otherwise, throws.
  ///
  /// Consider using [nullOrAlias] or [aliasKeyOrNull] depending on the
  /// context which are lenient.
  AliasDelegate<R> referenceAlias(
    Alias property, {
    required int indentLevel,
    required int indent,
    required RuneOffset start,
  }) {
    final Alias(:alias, :span) = property;

    if (_anchorNodes.containsKey(alias)) {
      return AliasDelegate<R>(
        _anchorNodes[alias] as R,
        refResolver: aliasFunction,
        indentLevel: indentLevel,
        indent: indent,
        start: start,
      )..hasLineBreak = property.isMultiline;
    }

    throwWithRangedOffset(
      scanner,
      message: 'Alias is not a valid anchor reference',
      start: span.start,
      end: span.end,
    );
  }

  /// Creates a [ParserDelegate] if the node's [property] is not empty and:
  ///   1. It is an alias, then an [AliasDelegate].
  ///   2. Has an anchor or tag, then a [ScalarDelegate] wrapping `null`
  T? nullOrAlias<T extends ParserDelegate<R>>(
    ParsedProperty property, {
    required int indentLevel,
    required int indent,
    required RuneOffset start,
    required RuneOffset end,
  }) {
    ParserDelegate<R>? node;

    switch (property) {
      case Alias alias:
        {
          node = referenceAlias(
            alias,
            indentLevel: indentLevel,
            indent: indent,
            start: start,
          )..updateNodeProperties = alias;
        }

      case NodeProperty present:
        {
          node = nullScalarDelegate(
            indentLevel: indentLevel,
            indent: indent,
            startOffset: start,
            resolver: scalarFunction,
          );

          trackAnchor(node, present);
        }

      default:
        break;
    }

    return node as T?;
  }

  /// Resets the parser's internal state variables before a new [YamlDocument]
  /// is parsed.
  void reset() {
    ++_currentIndex; // Move to next document

    if (_currentIndex == 0) return;

    hasDirectives = false;
    docStartExplicit = false;
    docEndExplicit = false;

    rootInMarkerLine = false;

    globalTags
      ..clear()
      ..addEntries([_defaultGlobalTag]);

    _anchorNodes.clear();
    comments = [];
  }

  /// Tracks the [marker] information after a [YamlDocument] has been
  /// completely parsed.
  void updateDocEndChars(DocumentMarker marker) {
    lastDocEndChars = marker.indicator;
    docEndExplicit = marker == DocumentMarker.documentEnd;

    if (docEndExplicit &&
        scanner.charAtCursor.isNotNullAnd(
          (c) => c == comment || c.isWhiteSpace() || c.isLineBreak(),
        )) {
      skipToParsableChar(scanner, onParseComment: comments.add);
    }
  }

  /// Resolves a [localTag] to a [GlobalTag] uri if present.
  ///
  /// If any [Resolver] matching the [localTag] is found, a
  /// [TypeResolverTag] is returned.
  OnTagResolved resolveTag(
    RuneOffset start,
    RuneOffset end,
    TagShorthand localTag,
  ) {
    final TagShorthand(:tagHandle, :content) = localTag;

    SpecificTag prefix = localTag;
    TagShorthand? suffix; // Local tags have no suffixes

    // Check if alias to global tag
    final globalTag = globalTags[tagHandle];
    final hasGlobalTag = globalTag != null;

    switch (tagHandle.handleVariant) {
      // All named tags must have a corresponding global tag
      case TagHandleVariant.named:
        {
          if (!hasGlobalTag) {
            throwWithRangedOffset(
              scanner,
              start: start,
              end: end,
              message: 'Named tags must have a corresponding global tag',
            );
          } else if (content.isEmpty) {
            throwWithRangedOffset(
              scanner,
              start: start,
              end: end,
              message: 'Named tags must have a non-empty suffix',
            );
          }

          continue resolver;
        }

      // Secondary tags limited to tags only supported by YAML
      case TagHandleVariant.secondary when !isYamlTag(localTag):
        throwWithRangedOffset(
          scanner,
          message:
              'Invalid secondary tag. Expected any of: '
              '$mappingTag, $orderedMappingTag, '
              '$sequenceTag, $setTag, '
              '$stringTag, $nullTag, $booleanTag, $integerTag or $floatTag',
          start: start,
          end: end,
        );

      resolver:
      default:
        {
          if (hasGlobalTag) {
            prefix = globalTag;
            suffix = localTag; // Local tag is prefixed with global tag uri
          }
        }
    }

    return (
      kind: switch (localTag.toString()) {
        '!!map' || '!!omap' => NodeKind.mapping,
        '!!seq' => NodeKind.sequence,
        '!!set' => NodeKind.set,
        _ when isYamlScalarTag(localTag) => NodeKind.scalar,
        _ => NodeKind.unknown,
      },

      /// Check if any resolvers were created. This conveniently allows
      /// non-specific tags to be captured for custom resolution before they are
      /// dropped.
      tag: switch (_resolvers[localTag]) {
        ResolverCreator function => function(NodeTag(prefix, suffix)),
        _ => NodeTag(prefix, suffix),
      },
    );
  }
}
