import 'package:rookie_yaml/src/parser/custom_resolvers.dart';
import 'package:rookie_yaml/src/parser/delegates/object_delegate.dart';
import 'package:rookie_yaml/src/parser/directives/directives.dart';
import 'package:rookie_yaml/src/parser/document/node_properties.dart';
import 'package:rookie_yaml/src/parser/document/nodes_by_kind/node_kind.dart';
import 'package:rookie_yaml/src/parser/document/state/custom_triggers.dart';
import 'package:rookie_yaml/src/parser/parser_utils.dart';
import 'package:rookie_yaml/src/scanner/source_iterator.dart';
import 'package:rookie_yaml/src/schema/nodes/yaml_node.dart';
import 'package:rookie_yaml/src/schema/yaml_comment.dart';
import 'package:rookie_yaml/src/schema/yaml_schema.dart';

final _defaultGlobalTag = MapEntry(TagHandle.secondary(), yamlGlobalTag);

/// A callback for handling map duplicates
typedef MapDuplicateHandler =
    void Function(RuneOffset keyStart, RuneOffset keyEnd, String message);

/// Logger callback
typedef ParserLogger = void Function(bool isInfo, String message);

/// [ResolvedTag] and the [NodeKind] represented by the tag.
typedef OnTagResolved = ({
  ResolvedTag tag,
  NodeKind kind,
  CustomResolver? customResolver,
});

/// A tag resolver callback
typedef TagResolver =
    OnTagResolved Function(RuneOffset start, RuneOffset end, TagShorthand tag);

typedef _OnCustomResolver = CustomResolver? Function(TagShorthand localTag);

typedef _OnScalarResolver<R> =
    ResolverCreator<R>? Function(TagShorthand localTag);

typedef OnMapKey = void Function(Object? key);

typedef _OnDefaultSeq<S> = OnCustomList<S>? Function();

typedef _OnDefaultMap<M> = OnCustomMap<M>? Function();

/// Just a null-ish helper.
R? _nullish<R>() => null;

/// Holds the document parser's top level state
final class ParserState<R> {
  ParserState(
    this.iterator, {
    required this.aliasFunction,
    required this.listFunction,
    required this.mapFunction,
    required this.scalarFunction,
    required this.logger,
    required this.onMapDuplicate,
    required CustomTriggers? triggers,
  }) : _onCustomResolver = triggers?.onCustomResolver ?? ((_) => null),
       _onScalarResolver = triggers?.onScalarResolver ?? ((_) => null),
       onParseMapKey = triggers?.onParsedKey ?? ((_) {}),
       _defaultMap = triggers?.onDefaultMapping ?? _nullish,
       _defaultSequence = triggers?.onDefaultSequence ?? _nullish;

  /// Byte iterator.
  final SourceIterator iterator;

  /// Alias builder
  final AliasFunction<R> aliasFunction;

  /// Sequence builder
  final ListFunction<R> listFunction;

  /// Map builder
  final MapFunction<R> mapFunction;

  /// Scalar builder
  final ScalarFunction<R> scalarFunction;

  /// Callback for binding a local tag to a custom resolver.
  final _OnCustomResolver _onCustomResolver;

  /// Callback for binding a local tag to a custom scalar resolver.
  final _OnScalarResolver _onScalarResolver;

  /// Callback once a valid map key has been parsed completely
  final OnMapKey onParseMapKey;

  /// Callback for creating a default sequence delegate.
  final _OnDefaultSeq<R> _defaultSequence;

  /// Callback for creating a default mapping delegate.
  final _OnDefaultMap<R> _defaultMap;

  /// Logging function for warnings and info
  final ParserLogger logger;

  /// Callback used to report keys that are duplicates in flow/block maps
  final MapDuplicateHandler onMapDuplicate;

  /// Global directives.
  ///
  /// Secondary tag always resolves
  final globalTags = Map.fromEntries([_defaultGlobalTag]);

  /// Index of document being parsed
  int _currentIndex = -1;

  /// Index of document being parsed
  int get current => _currentIndex;

  /// Char sequence that terminated the last document.
  ///
  /// If `...`, the parser looks for directives first before parsing can
  /// start until an explicit `---` is encountered. Throws an error otherwise.
  ///
  /// If `---`, the parser starts parsing nodes immediately. This also limits
  /// the use of `%` as the first character for plain style-like nodes, that is,
  /// [ScalarStyle.plain], [ScalarStyle.literal] and [ScalarStyle.folded]. The
  /// character cannot be used if the indent level is `0`.
  String lastDocEndChars = '';

  /// Tracks if the current document has an explicit start.
  ///
  /// End of directives. `---` at beginning.
  bool docStartExplicit = false;

  /// Tracks if last document had an explicit end.
  ///
  /// `...` at the end.
  bool docEndExplicit = false;

  /// Tracks whether any directives were declared
  bool hasDirectives = false;

  /// Tracks anchors that can be used as aliases
  final _anchorNodes = <String, R>{};

  /// Buffers all parsed comments
  var comments = <YamlComment>[];

  /// Tracks the object [R] generated by the [delegate] if [property] is not
  /// null and anchor is present.
  T trackAnchor<T extends NodeDelegate>(
    T delegate,
    ParsedProperty? property,
  ) {
    delegate.updateNodeProperties = property;

    if (property case NodeProperty(:final String anchor)) {
      _anchorNodes[anchor] = delegate.parsed();
    }

    return delegate;
  }

  /// Returns an [AliasDelegate] if [alias] has a corresponding anchor.
  /// Otherwise, throws.
  ///
  /// Consider using [nullOrAlias] or [aliasKeyOrNull] depending on the
  /// context which are lenient.
  AliasDelegate<R> referenceAlias(
    Alias property, {
    required int indentLevel,
    required int indent,
    required RuneOffset start,
  }) {
    final Alias(:alias, :span) = property;

    if (_anchorNodes.containsKey(alias)) {
      return AliasDelegate<R>(
        _anchorNodes[alias] as R,
        refResolver: aliasFunction,
        indentLevel: indentLevel,
        indent: indent,
        start: start,
      )..hasLineBreak = property.isMultiline;
    }

    throwWithRangedOffset(
      iterator,
      message: 'Alias is not a valid anchor reference',
      start: span.start,
      end: span.end,
    );
  }

  /// Creates a [NodeDelegate] if the node's [property] is not empty and:
  ///   1. It is an alias, then an [AliasDelegate].
  ///   2. Has an anchor or tag, then a [ScalarDelegate] wrapping `null`
  T? nullOrAlias<T extends NodeDelegate<R>>(
    ParsedProperty property, {
    required int indentLevel,
    required int indent,
    required RuneOffset start,
    required RuneOffset end,
  }) {
    NodeDelegate<R>? node;

    switch (property) {
      case Alias alias:
        {
          node = referenceAlias(
            alias,
            indentLevel: indentLevel,
            indent: indent,
            start: start,
          )..updateNodeProperties = alias;
        }

      case NodeProperty present:
        {
          node = nullScalarDelegate(
            indentLevel: indentLevel,
            indent: indent,
            startOffset: start,
            resolver: scalarFunction,
          );

          trackAnchor(node, present);
        }

      default:
        break;
    }

    return node as T?;
  }

  /// Resets the parser's internal state variables before a new [YamlDocument]
  /// is parsed.
  void reset() {
    ++_currentIndex; // Move to next document

    if (_currentIndex == 0) return;

    hasDirectives = false;
    docStartExplicit = lastDocEndChars == '---';
    docEndExplicit = false;

    globalTags
      ..clear()
      ..addEntries([_defaultGlobalTag]);

    _anchorNodes.clear();
    comments = [];
  }

  /// Tracks the [marker] information after a [YamlDocument] has been
  /// completely parsed.
  void updateDocEndChars(DocumentMarker marker) {
    lastDocEndChars = marker.indicator;
    docEndExplicit = marker == DocumentMarker.documentEnd;

    if (docEndExplicit &&
        !iterator.isEOF &&
        (iterator.current == comment ||
            iterator.current.isWhiteSpace() ||
            iterator.current.isLineBreak())) {
      skipToParsableChar(iterator, onParseComment: comments.add);
    }
  }

  /// Resolves a [localTag] to a [GlobalTag] uri if present.
  OnTagResolved resolveTag(
    RuneOffset start,
    RuneOffset end,
    TagShorthand localTag,
  ) {
    final TagShorthand(:tagHandle, :content) = localTag;

    SpecificTag prefix = localTag;
    TagShorthand? suffix; // Local tags have no suffixes

    // Check if alias to global tag
    final globalTag = globalTags[tagHandle];
    final hasGlobalTag = globalTag != null;

    switch (tagHandle.handleVariant) {
      // All named tags must have a corresponding global tag
      case TagHandleVariant.named:
        {
          if (!hasGlobalTag) {
            throwWithRangedOffset(
              iterator,
              start: start,
              end: end,
              message: 'Named tags must have a corresponding global tag',
            );
          } else if (content.isEmpty) {
            throwWithRangedOffset(
              iterator,
              start: start,
              end: end,
              message: 'Named tags must have a non-empty suffix',
            );
          }

          continue resolver;
        }

      // Secondary tags limited to tags only supported by YAML
      // TODO: Throw for yaml tag only
      case TagHandleVariant.secondary when !isYamlTag(localTag):
        throwWithRangedOffset(
          iterator,
          message:
              'Invalid secondary tag. Expected any of: '
              '$mappingTag, $orderedMappingTag, '
              '$sequenceTag, $setTag, '
              '$stringTag, $nullTag, $booleanTag, $integerTag or $floatTag',
          start: start,
          end: end,
        );

      resolver:
      default:
        {
          if (hasGlobalTag) {
            prefix = globalTag;
            suffix = localTag; // Local tag is prefixed with global tag uri
          }
        }
    }

    NodeKind? kind;
    CustomResolver? customResolver;
    ResolvedTag nodeTag = NodeTag(prefix, suffix);

    // A local tag cannot be treated as both a custom resolver and a scalar
    // resolver. Give preference to a custom resolver. This conveniently
    // allows non-specific tags to be captured for custom resolution before
    // they are dropped.
    if (_onCustomResolver(localTag) case CustomResolver resolver) {
      kind = resolver.kind;
      customResolver = resolver;
    } else if (_onScalarResolver(localTag)
        case ResolverCreator<Object?> function) {
      nodeTag = function(nodeTag as NodeTag);
      kind = YamlScalarKind.stringToType;
    }

    return (
      kind:
          kind ??
          switch (localTag.toString()) {
            '!!map' => YamlCollectionKind.mapping,
            '!!omap' => YamlCollectionKind.orderedMap,
            '!!seq' => YamlCollectionKind.sequence,
            '!!set' => YamlCollectionKind.set,
            '!!str' => YamlScalarKind.string,
            '!!null' => YamlScalarKind.nullString,
            '!!bool' => YamlScalarKind.booleanString,
            '!!int' => YamlScalarKind.integer,
            '!!float' => YamlScalarKind.float,
            _ when !hasGlobalTag && localTag.isNonSpecific =>
              NodeKind.generic(),
            _ => NodeKind.unknown(),
          },
      tag: nodeTag,
      customResolver: customResolver,
    );
  }

  /// Creates a generic map delegate.
  MapLikeDelegate<R, R> defaultMapDelegate({
    required NodeStyle mapStyle,
    required int indentLevel,
    required int indent,
    required RuneOffset start,
  }) => switch (_defaultMap()) {
    OnCustomMap<R> customMap => MapLikeDelegate.boxed(
      customMap(),
      collectionStyle: mapStyle,
      indentLevel: indentLevel,
      indent: indent,
      start: start,
    ),
    _ => GenericMap(
      collectionStyle: mapStyle,
      indentLevel: indentLevel,
      indent: indent,
      start: start,
      mapResolver: mapFunction,
    ),
  };

  /// Creates a generic sequence delegate.
  SequenceLikeDelegate<R, R> defaultSequenceDelegate({
    required NodeStyle style,
    required int indent,
    required int indentLevel,
    required RuneOffset start,
    NodeKind kind = YamlKind.sequence,
  }) => switch (_defaultSequence()) {
    OnCustomList<R> customList => SequenceLikeDelegate.boxed(
      customList(),
      collectionStyle: style,
      indentLevel: indentLevel,
      indent: indent,
      start: start,
    ),
    _ => GenericSequence.byKind(
      style: style,
      indent: indent,
      indentLevel: indentLevel,
      start: start,
      resolver: listFunction,
      kind: kind,
    ),
  };
}
